{"ast":null,"code":"var _jsxFileName = \"D:\\\\Program Files\\\\WebstormProjects\\\\soil_scout\\\\web\\\\src\\\\contexts\\\\UserContext.js\",\n  _s = $RefreshSig$();\nimport { createContext, useState, useEffect } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport Cookies from 'js-cookie';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const UserContext = /*#__PURE__*/createContext(null);\nexport function UserProvider({\n  children\n}) {\n  _s();\n  const [user, setUser] = useState(null);\n  const [isLoading, setIsLoading] = useState(true); // Додано стан завантаження\n  const navigate = useNavigate();\n  useEffect(() => {\n    const token = Cookies.get(\"auth_token\");\n    const storedUser = localStorage.getItem('user'); // Спробуємо взяти збереженого юзера\n\n    if (token) {\n      try {\n        // Якщо є збережений юзер, використовуємо його\n        // ВАЖЛИВО: У реальному додатку тут може бути запит до API для валідації токена\n        // та отримання актуальних даних користувача.\n        if (storedUser) {\n          setUser(JSON.parse(storedUser));\n        } else {\n          // Якщо юзера в localStorage нема, але є токен,\n          // можна встановити базовий стан або зробити запит на /profile\n          // Поки що встановимо лише токен, але це може бути недостатньо\n          setUser({\n            token\n          }); // Або { id: 'unknown', token: token } чи результат API запиту\n        }\n      } catch (error) {\n        console.error(\"Failed to parse user from localStorage\", error);\n        // Якщо помилка парсингу, краще вийти\n        logout();\n      }\n    } else {\n      // Якщо токена немає, переконуємось, що стан чистий\n      if (user) {\n        // Перевірка, щоб уникнути зайвого ререндеру\n        setUser(null);\n      }\n      if (storedUser) {\n        // Видаляємо невалідні дані з localStorage\n        localStorage.removeItem('user');\n      }\n    }\n    setIsLoading(false); // Завершуємо завантаження після перевірки\n  }, []); // Запускаємо лише один раз при монтуванні\n\n  const login = userData => {\n    // Переконайтесь, що userData містить токен, якщо сервер його не встановлює через Set-Cookie\n    const token = userData.token || Cookies.get(\"auth_token\"); // Отримуємо токен\n\n    if (token) {\n      // Встановлюємо кукі, якщо сервер цього не робить (краще щоб робив сервер)\n      // Cookies.set(\"auth_token\", token, { expires: 7, path: '/' /* , secure: true, sameSite: 'strict' */ });\n\n      localStorage.setItem('user', JSON.stringify(userData));\n      setUser(userData);\n    } else {\n      console.error(\"Login failed: No token provided in userData\");\n      // Можливо, показати помилку користувачу\n    }\n  };\n  const logout = () => {\n    localStorage.removeItem('user');\n    Cookies.remove(\"auth_token\", {\n      path: '/'\n    }); // Вкажіть path, якщо він використовувався при встановленні\n    setUser(null);\n    // Не потрібно setIsLoading(true) тут, бо navigate спрацює\n    navigate('/login');\n  };\n\n  // checkToken може бути корисним для перевірок всередині компонентів, але не для основного захисту маршрутів\n  const checkToken = () => {\n    return !!Cookies.get(\"auth_token\");\n  };\n\n  // Передаємо isLoading у value\n  return /*#__PURE__*/_jsxDEV(UserContext.Provider, {\n    value: {\n      user,\n      login,\n      logout,\n      checkToken,\n      isLoading\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 77,\n    columnNumber: 9\n  }, this);\n}\n_s(UserProvider, \"o5QfC7aYrUkj9YQ0lGSakMfCddo=\", false, function () {\n  return [useNavigate];\n});\n_c = UserProvider;\nvar _c;\n$RefreshReg$(_c, \"UserProvider\");","map":{"version":3,"names":["createContext","useState","useEffect","useNavigate","Cookies","jsxDEV","_jsxDEV","UserContext","UserProvider","children","_s","user","setUser","isLoading","setIsLoading","navigate","token","get","storedUser","localStorage","getItem","JSON","parse","error","console","logout","removeItem","login","userData","setItem","stringify","remove","path","checkToken","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/Program Files/WebstormProjects/soil_scout/web/src/contexts/UserContext.js"],"sourcesContent":["import { createContext, useState, useEffect } from \"react\";\r\nimport { useNavigate } from \"react-router-dom\";\r\nimport Cookies from 'js-cookie';\r\n\r\nexport const UserContext = createContext(null);\r\n\r\nexport function UserProvider({ children }) {\r\n    const [user, setUser] = useState(null);\r\n    const [isLoading, setIsLoading] = useState(true); // Додано стан завантаження\r\n    const navigate = useNavigate();\r\n\r\n    useEffect(() => {\r\n        const token = Cookies.get(\"auth_token\");\r\n        const storedUser = localStorage.getItem('user'); // Спробуємо взяти збереженого юзера\r\n\r\n        if (token) {\r\n            try {\r\n                // Якщо є збережений юзер, використовуємо його\r\n                // ВАЖЛИВО: У реальному додатку тут може бути запит до API для валідації токена\r\n                // та отримання актуальних даних користувача.\r\n                if (storedUser) {\r\n                    setUser(JSON.parse(storedUser));\r\n                } else {\r\n                    // Якщо юзера в localStorage нема, але є токен,\r\n                    // можна встановити базовий стан або зробити запит на /profile\r\n                    // Поки що встановимо лише токен, але це може бути недостатньо\r\n                    setUser({ token }); // Або { id: 'unknown', token: token } чи результат API запиту\r\n                }\r\n            } catch (error) {\r\n                console.error(\"Failed to parse user from localStorage\", error);\r\n                // Якщо помилка парсингу, краще вийти\r\n                logout();\r\n            }\r\n        } else {\r\n            // Якщо токена немає, переконуємось, що стан чистий\r\n            if (user) { // Перевірка, щоб уникнути зайвого ререндеру\r\n                setUser(null);\r\n            }\r\n            if (storedUser) { // Видаляємо невалідні дані з localStorage\r\n                localStorage.removeItem('user');\r\n            }\r\n        }\r\n        setIsLoading(false); // Завершуємо завантаження після перевірки\r\n    }, []); // Запускаємо лише один раз при монтуванні\r\n\r\n    const login = (userData) => {\r\n        // Переконайтесь, що userData містить токен, якщо сервер його не встановлює через Set-Cookie\r\n        const token = userData.token || Cookies.get(\"auth_token\"); // Отримуємо токен\r\n\r\n        if (token) {\r\n            // Встановлюємо кукі, якщо сервер цього не робить (краще щоб робив сервер)\r\n            // Cookies.set(\"auth_token\", token, { expires: 7, path: '/' /* , secure: true, sameSite: 'strict' */ });\r\n\r\n            localStorage.setItem('user', JSON.stringify(userData));\r\n            setUser(userData);\r\n        } else {\r\n            console.error(\"Login failed: No token provided in userData\");\r\n            // Можливо, показати помилку користувачу\r\n        }\r\n    };\r\n\r\n    const logout = () => {\r\n        localStorage.removeItem('user');\r\n        Cookies.remove(\"auth_token\", { path: '/' }); // Вкажіть path, якщо він використовувався при встановленні\r\n        setUser(null);\r\n        // Не потрібно setIsLoading(true) тут, бо navigate спрацює\r\n        navigate('/login');\r\n    };\r\n\r\n    // checkToken може бути корисним для перевірок всередині компонентів, але не для основного захисту маршрутів\r\n    const checkToken = () => {\r\n        return !!Cookies.get(\"auth_token\");\r\n    };\r\n\r\n    // Передаємо isLoading у value\r\n    return (\r\n        <UserContext.Provider value={{ user, login, logout, checkToken, isLoading }}>\r\n            {children}\r\n        </UserContext.Provider>\r\n    );\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}