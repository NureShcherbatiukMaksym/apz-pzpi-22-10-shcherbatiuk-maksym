{"ast":null,"code":"// utils/api.js\nimport axios from 'axios';\nconst api = axios.create({\n  baseURL: 'http://localhost:5000/api',\n  // або твій домен\n  withCredentials: true // якщо токени/сесія у cookie\n});\nlet onUnauthorizedCallback = null;\n// Додаємо прапорець, щоб уникнути безкінечних циклів перехоплювача\nlet isLoggingOut = false;\nexport const setUnauthorizedCallback = callback => {\n  onUnauthorizedCallback = callback;\n};\n\n// Функція для UserContext, щоб встановити статус виходу\nexport const setIsLoggingOut = status => {\n  isLoggingOut = status;\n  console.log('API Interceptor: isLoggingOut set to', isLoggingOut);\n};\n\n// Додаємо інтерцептор для відповідей\napi.interceptors.response.use(response => response, async error => {\n  var _error$response, _error$response2;\n  // Перевіряємо, чи це помилка відповіді від сервера, статус 401\n  // АЛЕ тільки якщо ми НЕ знаходимося вже в процесі виходу (isLoggingOut === false)\n  if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401 && !isLoggingOut) {\n    console.error('API Interceptor: Received 401 Unauthorized. Initiating logout.');\n    // Встановлюємо прапорець відразу, щоб запобігти подальшим викликам\n    setIsLoggingOut(true);\n\n    // Викликаємо зворотний виклик (logoutUser з контексту), якщо він встановлений\n    if (onUnauthorizedCallback) {\n      try {\n        // Чекаємо завершення процесу виходу\n        await onUnauthorizedCallback();\n      } catch (logoutErr) {\n        console.error('API Interceptor: Error during unauthorized callback execution:', logoutErr);\n        // Продовжуємо відхиляти оригінальну помилку\n      } finally {\n        // Прапорець isLoggingOut має бути скинутий у callback-функції (logoutUser)\n        // після завершення очищення стану/localStorage.\n      }\n    } else {\n      console.warn('API Interceptor: 401 received, but no unauthorized callback is set.');\n      // Якщо callback не встановлено, скидаємо прапорець тут, щоб не заблокувати майбутні спроби\n      setIsLoggingOut(false);\n    }\n  } else if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 401 && isLoggingOut) {\n    console.log('API Interceptor: Received 401 while already logging out. Ignoring.');\n    // Ігноруємо 401, якщо ми вже в процесі виходу, щоб уникнути циклу.\n  }\n\n  // Важливо: завжди повертаємо помилку, щоб компонент, який зробив запит, міг її обробити.\n  // Компонент повинен бути готовий до помилок і, можливо, перевірити статус користувача після отримання помилки.\n  return Promise.reject(error);\n});\nexport default api;","map":{"version":3,"names":["axios","api","create","baseURL","withCredentials","onUnauthorizedCallback","isLoggingOut","setUnauthorizedCallback","callback","setIsLoggingOut","status","console","log","interceptors","response","use","error","_error$response","_error$response2","logoutErr","warn","Promise","reject"],"sources":["D:/Program Files/WebstormProjects/soil_scout/web/src/utils/api.js"],"sourcesContent":["// utils/api.js\r\nimport axios from 'axios';\r\n\r\nconst api = axios.create({\r\n    baseURL: 'http://localhost:5000/api', // або твій домен\r\n    withCredentials: true, // якщо токени/сесія у cookie\r\n});\r\n\r\nlet onUnauthorizedCallback = null;\r\n// Додаємо прапорець, щоб уникнути безкінечних циклів перехоплювача\r\nlet isLoggingOut = false;\r\n\r\nexport const setUnauthorizedCallback = (callback) => {\r\n    onUnauthorizedCallback = callback;\r\n};\r\n\r\n// Функція для UserContext, щоб встановити статус виходу\r\nexport const setIsLoggingOut = (status) => {\r\n    isLoggingOut = status;\r\n    console.log('API Interceptor: isLoggingOut set to', isLoggingOut);\r\n};\r\n\r\n\r\n// Додаємо інтерцептор для відповідей\r\napi.interceptors.response.use(\r\n    response => response,\r\n    async error => {\r\n        // Перевіряємо, чи це помилка відповіді від сервера, статус 401\r\n        // АЛЕ тільки якщо ми НЕ знаходимося вже в процесі виходу (isLoggingOut === false)\r\n        if (error.response?.status === 401 && !isLoggingOut) {\r\n            console.error('API Interceptor: Received 401 Unauthorized. Initiating logout.');\r\n            // Встановлюємо прапорець відразу, щоб запобігти подальшим викликам\r\n            setIsLoggingOut(true);\r\n\r\n            // Викликаємо зворотний виклик (logoutUser з контексту), якщо він встановлений\r\n            if (onUnauthorizedCallback) {\r\n                try {\r\n                    // Чекаємо завершення процесу виходу\r\n                    await onUnauthorizedCallback();\r\n                } catch (logoutErr) {\r\n                    console.error('API Interceptor: Error during unauthorized callback execution:', logoutErr);\r\n                    // Продовжуємо відхиляти оригінальну помилку\r\n                } finally {\r\n                    // Прапорець isLoggingOut має бути скинутий у callback-функції (logoutUser)\r\n                    // після завершення очищення стану/localStorage.\r\n                }\r\n            } else {\r\n                console.warn('API Interceptor: 401 received, but no unauthorized callback is set.');\r\n                // Якщо callback не встановлено, скидаємо прапорець тут, щоб не заблокувати майбутні спроби\r\n                setIsLoggingOut(false);\r\n            }\r\n        } else if (error.response?.status === 401 && isLoggingOut) {\r\n            console.log('API Interceptor: Received 401 while already logging out. Ignoring.');\r\n            // Ігноруємо 401, якщо ми вже в процесі виходу, щоб уникнути циклу.\r\n        }\r\n\r\n\r\n        // Важливо: завжди повертаємо помилку, щоб компонент, який зробив запит, міг її обробити.\r\n        // Компонент повинен бути готовий до помилок і, можливо, перевірити статус користувача після отримання помилки.\r\n        return Promise.reject(error);\r\n    }\r\n);\r\n\r\nexport default api;"],"mappings":"AAAA;AACA,OAAOA,KAAK,MAAM,OAAO;AAEzB,MAAMC,GAAG,GAAGD,KAAK,CAACE,MAAM,CAAC;EACrBC,OAAO,EAAE,2BAA2B;EAAE;EACtCC,eAAe,EAAE,IAAI,CAAE;AAC3B,CAAC,CAAC;AAEF,IAAIC,sBAAsB,GAAG,IAAI;AACjC;AACA,IAAIC,YAAY,GAAG,KAAK;AAExB,OAAO,MAAMC,uBAAuB,GAAIC,QAAQ,IAAK;EACjDH,sBAAsB,GAAGG,QAAQ;AACrC,CAAC;;AAED;AACA,OAAO,MAAMC,eAAe,GAAIC,MAAM,IAAK;EACvCJ,YAAY,GAAGI,MAAM;EACrBC,OAAO,CAACC,GAAG,CAAC,sCAAsC,EAAEN,YAAY,CAAC;AACrE,CAAC;;AAGD;AACAL,GAAG,CAACY,YAAY,CAACC,QAAQ,CAACC,GAAG,CACzBD,QAAQ,IAAIA,QAAQ,EACpB,MAAME,KAAK,IAAI;EAAA,IAAAC,eAAA,EAAAC,gBAAA;EACX;EACA;EACA,IAAI,EAAAD,eAAA,GAAAD,KAAK,CAACF,QAAQ,cAAAG,eAAA,uBAAdA,eAAA,CAAgBP,MAAM,MAAK,GAAG,IAAI,CAACJ,YAAY,EAAE;IACjDK,OAAO,CAACK,KAAK,CAAC,gEAAgE,CAAC;IAC/E;IACAP,eAAe,CAAC,IAAI,CAAC;;IAErB;IACA,IAAIJ,sBAAsB,EAAE;MACxB,IAAI;QACA;QACA,MAAMA,sBAAsB,CAAC,CAAC;MAClC,CAAC,CAAC,OAAOc,SAAS,EAAE;QAChBR,OAAO,CAACK,KAAK,CAAC,gEAAgE,EAAEG,SAAS,CAAC;QAC1F;MACJ,CAAC,SAAS;QACN;QACA;MAAA;IAER,CAAC,MAAM;MACHR,OAAO,CAACS,IAAI,CAAC,qEAAqE,CAAC;MACnF;MACAX,eAAe,CAAC,KAAK,CAAC;IAC1B;EACJ,CAAC,MAAM,IAAI,EAAAS,gBAAA,GAAAF,KAAK,CAACF,QAAQ,cAAAI,gBAAA,uBAAdA,gBAAA,CAAgBR,MAAM,MAAK,GAAG,IAAIJ,YAAY,EAAE;IACvDK,OAAO,CAACC,GAAG,CAAC,oEAAoE,CAAC;IACjF;EACJ;;EAGA;EACA;EACA,OAAOS,OAAO,CAACC,MAAM,CAACN,KAAK,CAAC;AAChC,CACJ,CAAC;AAED,eAAef,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}