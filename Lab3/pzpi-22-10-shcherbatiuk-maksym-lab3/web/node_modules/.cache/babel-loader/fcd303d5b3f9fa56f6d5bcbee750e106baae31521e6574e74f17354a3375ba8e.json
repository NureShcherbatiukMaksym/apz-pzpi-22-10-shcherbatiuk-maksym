{"ast":null,"code":"var _jsxFileName = \"D:\\\\Program Files\\\\WebstormProjects\\\\soil_scout\\\\web\\\\src\\\\contexts\\\\UserContext.js\",\n  _s = $RefreshSig$();\n// contexts/UserContext.js\nimport React, { createContext, useState, useEffect, useCallback } from 'react';\n// Імпортуємо setUnauthorizedCallback та setIsLoggingOut\nimport api, { setUnauthorizedCallback, setIsLoggingOut } from '../utils/api';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const UserContext = /*#__PURE__*/createContext();\nexport const UserProvider = ({\n  children\n}) => {\n  _s();\n  // Початковий стан: ініціалізуємо з localStorage, припускаємо, що пристрою немає\n  const [user, setUser] = useState(() => {\n    const storedUserName = localStorage.getItem('userName');\n    return storedUserName ? {\n      name: storedUserName\n    } : null;\n  });\n  const [isAdmin, setIsAdmin] = useState(() => localStorage.getItem('isAdmin') === 'true');\n  const [hasDevice, setHasDevice] = useState(false); // Статус пристрою невідомий при старті\n  // Loading для індикації процесу перевірки пристрою\n  const [loadingDevice, setLoadingDevice] = useState(false);\n  // Global loading для початкового завантаження контексту (читання LS + перша перевірка пристрою)\n  const [loadingInitial, setLoadingInitial] = useState(true); // Старт з true\n  const [error, setError] = useState(null); // Загальний стан помилки\n\n  // --- Функція перевірки наявності пристрою ---\n  const checkDeviceStatus = useCallback(async () => {\n    // Робимо перевірку лише якщо користувач виглядає залогіненим (присутній user об'єкт)\n    // і ми ще не перевіряємо його пристрій\n    if (!user || loadingDevice) {\n      // console.log('Context: Skipping device check - not logged in or already checking.');\n      if (!user) setHasDevice(false); // Якщо user = null, пристрою точно немає\n      return; // Не виконуємо запит, якщо немає user або вже йде завантаження\n    }\n    setLoadingDevice(true);\n    console.log('Context: Performing device status check...');\n    try {\n      const devicesRes = await api.get('/user-iot-devices');\n      const userHasDevice = devicesRes.data && devicesRes.data.length > 0;\n      setHasDevice(userHasDevice);\n      console.log(`Context: Device check successful. Has device: ${userHasDevice}.`);\n      // setError(null); // Очищаємо помилку, якщо була\n    } catch (err) {\n      var _err$response;\n      console.error('Context: Failed to fetch user devices:', err);\n      // Перехоплювач обробить 401. Для інших помилок, вважаємо, що пристрій недоступний.\n      if (((_err$response = err.response) === null || _err$response === void 0 ? void 0 : _err$response.status) !== 401) {\n        setHasDevice(false);\n        //setError(err); // Можна встановити помилку, якщо потрібно відобразити\n      }\n      // else: 401 handled by interceptor -> logoutUser will clear state\n    } finally {\n      setLoadingDevice(false);\n    }\n  }, [user, loadingDevice]); // Залежність від user та loadingDevice\n\n  // --- Початкова перевірка при монтуванні ---\n  useEffect(() => {\n    // Після ініціалізації стану з localStorage\n    const storedUserName = localStorage.getItem('userName');\n    const initialUser = storedUserName ? {\n      name: storedUserName\n    } : null;\n\n    // Якщо user об'єкт присутній (навіть з localStorage), запускаємо перевірку пристрою\n    if (initialUser) {\n      // Асинхронно викликаємо перевірку пристрою. Це не блокує рендеринг.\n      checkDeviceStatus();\n    } else {\n      // Якщо user = null з самого початку, пристрою немає\n      setHasDevice(false);\n    }\n\n    // Початкове завантаження завершено після ініціалізації з LS та запуску (або пропуску) перевірки пристрою\n    setLoadingInitial(false);\n    console.log('Context: Initial user and device check setup complete.');\n  }, [checkDeviceStatus]); // Залежність від checkDeviceStatus (обгорнутий в useCallback)\n\n  // --- Логіка Виходу ---\n  const logoutUser = useCallback(async () => {\n    console.log('Context: logoutUser called.');\n\n    // setIsLoggingOut(true) встановлюється перехоплювачем ПЕРЕД викликом цієї функції при 401.\n    // Якщо функція викликана компонентом напряму (кнопка \"Вийти\"), встановлюємо прапорець тут:\n    // if (!isLoggingOut) setIsLoggingOut(true); // Додайте це, якщо викликаєте logoutUser з компонентів\n\n    // Опціонально: викликаємо endpoint для виходу на бекенді\n    try {\n      console.log('Context: Attempting backend /auth/logout call (optional)...');\n      // await api.post('/auth/logout'); // Розкоментуйте, якщо маєте такий endpoint\n      console.log('Context: Backend logout call finished (or skipped).');\n    } catch (err) {\n      console.error('Context: Failed to call backend logout API:', err);\n    } finally {\n      // --- Очищення стану та localStorage ---\n      console.log('Context: Performing local logout cleanup.');\n      setUser(null);\n      setIsAdmin(false);\n      setHasDevice(false); // При виході пристрою точно немає\n      localStorage.removeItem('userName');\n      localStorage.removeItem('isAdmin');\n      // localStorage.removeItem('token'); // Розкоментуйте, якщо зберігаєте токен у localStorage\n\n      // *** СКИНУТИ прапорець isLoggingOut ПІСЛЯ очищення стану ***\n      setIsLoggingOut(false);\n      console.log('Context: logoutUser finished, setIsLoggingOut(false).');\n\n      // *** ВАЖЛИВО: Перенаправлення на /login сторінку відбувається в App (або роутері),\n      // який спостерігає за зміною стану 'user' на null. ***\n    }\n  }, []);\n\n  // --- Зв'язуємо logoutUser з перехоплювачем API ---\n  useEffect(() => {\n    console.log('Context: Setting API unauthorized callback.');\n    setUnauthorizedCallback(logoutUser);\n    return () => {\n      console.log('Context: Clearing API unauthorized callback.');\n      setUnauthorizedCallback(null);\n      setIsLoggingOut(false); // Скидаємо прапорець при демонтажі\n    };\n  }, [logoutUser]);\n\n  // --- Функція для обробки успіху логіну (викликається з LoginPage) ---\n  const handleLoginSuccess = useCallback(userDataFromLogin => {\n    console.log('Context: handleLoginSuccess called.');\n    // Оновлюємо стан користувача на основі даних з логіну\n    setUser({\n      name: userDataFromLogin.name\n    });\n    setIsAdmin(userDataFromLogin.is_admin || false);\n    // setHasDevice залишається false поки не завершиться checkDeviceStatus\n    setError(null); // Очищаємо помилки\n\n    // *** ЗАПУСКАЄМО ПЕРЕВІРКУ ПРИСТРОЮ ПІСЛЯ УСПІШНОГО ЛОГІНУ ***\n    // checkDeviceStatus relies on 'user' state, so we need to make sure\n    // the state update (setUser) has potentially processed before calling it.\n    // Calling it immediately after setUser might work due to state batching\n    // or the way useEffect dependencies work, but ensuring 'user' is non-null\n    // within checkDeviceStatus handles potential timing issues.\n    checkDeviceStatus(); // Викликаємо перевірку пристрою\n\n    // localStorage вже збережено в LoginPage, але можна зробити це і тут,\n    // якщо хочете централізувати логіку збереження після успіху\n    // localStorage.setItem('userName', userDataFromLogin.name);\n    // localStorage.setItem('isAdmin', userDataFromLogin.is_admin ? 'true' : 'false');\n    // console.log('Context: userName and isAdmin saved to localStorage via context.');\n  }, [checkDeviceStatus]); // Залежність від checkDeviceStatus\n\n  // Значення контексту, що передається\n  const contextValue = {\n    user,\n    // null або { name: string }\n    isAdmin,\n    // boolean\n    hasDevice,\n    // boolean (статус пристрою)\n    loadingInitial,\n    // boolean (чи йде початкове завантаження контексту)\n    loadingDevice,\n    // boolean (чи йде перевірка пристрою)\n    error,\n    // any\n    logoutUser,\n    // Функція для виходу\n    handleLoginSuccess,\n    // Функція для LoginPage при успішному логіні\n    checkDeviceStatus // Може знадобитись деінде для оновлення статусу пристрою\n  };\n  return /*#__PURE__*/_jsxDEV(UserContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 162,\n    columnNumber: 9\n  }, this);\n};\n_s(UserProvider, \"ym8If2rWVQFShcNPYX66vAnkXSg=\");\n_c = UserProvider;\nvar _c;\n$RefreshReg$(_c, \"UserProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useCallback","api","setUnauthorizedCallback","setIsLoggingOut","jsxDEV","_jsxDEV","UserContext","UserProvider","children","_s","user","setUser","storedUserName","localStorage","getItem","name","isAdmin","setIsAdmin","hasDevice","setHasDevice","loadingDevice","setLoadingDevice","loadingInitial","setLoadingInitial","error","setError","checkDeviceStatus","console","log","devicesRes","get","userHasDevice","data","length","err","_err$response","response","status","initialUser","logoutUser","removeItem","handleLoginSuccess","userDataFromLogin","is_admin","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/Program Files/WebstormProjects/soil_scout/web/src/contexts/UserContext.js"],"sourcesContent":["// contexts/UserContext.js\r\nimport React, { createContext, useState, useEffect, useCallback } from 'react';\r\n// Імпортуємо setUnauthorizedCallback та setIsLoggingOut\r\nimport api, { setUnauthorizedCallback, setIsLoggingOut } from '../utils/api';\r\n\r\nexport const UserContext = createContext();\r\n\r\nexport const UserProvider = ({ children }) => {\r\n    // Початковий стан: ініціалізуємо з localStorage, припускаємо, що пристрою немає\r\n    const [user, setUser] = useState(() => {\r\n        const storedUserName = localStorage.getItem('userName');\r\n        return storedUserName ? { name: storedUserName } : null;\r\n    });\r\n    const [isAdmin, setIsAdmin] = useState(() => localStorage.getItem('isAdmin') === 'true');\r\n    const [hasDevice, setHasDevice] = useState(false); // Статус пристрою невідомий при старті\r\n    // Loading для індикації процесу перевірки пристрою\r\n    const [loadingDevice, setLoadingDevice] = useState(false);\r\n    // Global loading для початкового завантаження контексту (читання LS + перша перевірка пристрою)\r\n    const [loadingInitial, setLoadingInitial] = useState(true); // Старт з true\r\n    const [error, setError] = useState(null); // Загальний стан помилки\r\n\r\n    // --- Функція перевірки наявності пристрою ---\r\n    const checkDeviceStatus = useCallback(async () => {\r\n        // Робимо перевірку лише якщо користувач виглядає залогіненим (присутній user об'єкт)\r\n        // і ми ще не перевіряємо його пристрій\r\n        if (!user || loadingDevice) {\r\n            // console.log('Context: Skipping device check - not logged in or already checking.');\r\n            if (!user) setHasDevice(false); // Якщо user = null, пристрою точно немає\r\n            return; // Не виконуємо запит, якщо немає user або вже йде завантаження\r\n        }\r\n\r\n        setLoadingDevice(true);\r\n        console.log('Context: Performing device status check...');\r\n        try {\r\n            const devicesRes = await api.get('/user-iot-devices');\r\n            const userHasDevice = devicesRes.data && devicesRes.data.length > 0;\r\n            setHasDevice(userHasDevice);\r\n            console.log(`Context: Device check successful. Has device: ${userHasDevice}.`);\r\n            // setError(null); // Очищаємо помилку, якщо була\r\n\r\n        } catch (err) {\r\n            console.error('Context: Failed to fetch user devices:', err);\r\n            // Перехоплювач обробить 401. Для інших помилок, вважаємо, що пристрій недоступний.\r\n            if (err.response?.status !== 401) {\r\n                setHasDevice(false);\r\n                //setError(err); // Можна встановити помилку, якщо потрібно відобразити\r\n            }\r\n            // else: 401 handled by interceptor -> logoutUser will clear state\r\n        } finally {\r\n            setLoadingDevice(false);\r\n        }\r\n    }, [user, loadingDevice]); // Залежність від user та loadingDevice\r\n\r\n    // --- Початкова перевірка при монтуванні ---\r\n    useEffect(() => {\r\n        // Після ініціалізації стану з localStorage\r\n        const storedUserName = localStorage.getItem('userName');\r\n        const initialUser = storedUserName ? { name: storedUserName } : null;\r\n\r\n        // Якщо user об'єкт присутній (навіть з localStorage), запускаємо перевірку пристрою\r\n        if (initialUser) {\r\n            // Асинхронно викликаємо перевірку пристрою. Це не блокує рендеринг.\r\n            checkDeviceStatus();\r\n        } else {\r\n            // Якщо user = null з самого початку, пристрою немає\r\n            setHasDevice(false);\r\n        }\r\n\r\n        // Початкове завантаження завершено після ініціалізації з LS та запуску (або пропуску) перевірки пристрою\r\n        setLoadingInitial(false);\r\n        console.log('Context: Initial user and device check setup complete.');\r\n\r\n    }, [checkDeviceStatus]); // Залежність від checkDeviceStatus (обгорнутий в useCallback)\r\n\r\n    // --- Логіка Виходу ---\r\n    const logoutUser = useCallback(async () => {\r\n        console.log('Context: logoutUser called.');\r\n\r\n        // setIsLoggingOut(true) встановлюється перехоплювачем ПЕРЕД викликом цієї функції при 401.\r\n        // Якщо функція викликана компонентом напряму (кнопка \"Вийти\"), встановлюємо прапорець тут:\r\n        // if (!isLoggingOut) setIsLoggingOut(true); // Додайте це, якщо викликаєте logoutUser з компонентів\r\n\r\n        // Опціонально: викликаємо endpoint для виходу на бекенді\r\n        try {\r\n            console.log('Context: Attempting backend /auth/logout call (optional)...');\r\n            // await api.post('/auth/logout'); // Розкоментуйте, якщо маєте такий endpoint\r\n            console.log('Context: Backend logout call finished (or skipped).');\r\n        } catch (err) {\r\n            console.error('Context: Failed to call backend logout API:', err);\r\n        } finally {\r\n            // --- Очищення стану та localStorage ---\r\n            console.log('Context: Performing local logout cleanup.');\r\n            setUser(null);\r\n            setIsAdmin(false);\r\n            setHasDevice(false); // При виході пристрою точно немає\r\n            localStorage.removeItem('userName');\r\n            localStorage.removeItem('isAdmin');\r\n            // localStorage.removeItem('token'); // Розкоментуйте, якщо зберігаєте токен у localStorage\r\n\r\n            // *** СКИНУТИ прапорець isLoggingOut ПІСЛЯ очищення стану ***\r\n            setIsLoggingOut(false);\r\n            console.log('Context: logoutUser finished, setIsLoggingOut(false).');\r\n\r\n            // *** ВАЖЛИВО: Перенаправлення на /login сторінку відбувається в App (або роутері),\r\n            // який спостерігає за зміною стану 'user' на null. ***\r\n        }\r\n    }, []);\r\n\r\n    // --- Зв'язуємо logoutUser з перехоплювачем API ---\r\n    useEffect(() => {\r\n        console.log('Context: Setting API unauthorized callback.');\r\n        setUnauthorizedCallback(logoutUser);\r\n\r\n        return () => {\r\n            console.log('Context: Clearing API unauthorized callback.');\r\n            setUnauthorizedCallback(null);\r\n            setIsLoggingOut(false); // Скидаємо прапорець при демонтажі\r\n        };\r\n    }, [logoutUser]);\r\n\r\n\r\n    // --- Функція для обробки успіху логіну (викликається з LoginPage) ---\r\n    const handleLoginSuccess = useCallback((userDataFromLogin) => {\r\n        console.log('Context: handleLoginSuccess called.');\r\n        // Оновлюємо стан користувача на основі даних з логіну\r\n        setUser({ name: userDataFromLogin.name });\r\n        setIsAdmin(userDataFromLogin.is_admin || false);\r\n        // setHasDevice залишається false поки не завершиться checkDeviceStatus\r\n        setError(null); // Очищаємо помилки\r\n\r\n        // *** ЗАПУСКАЄМО ПЕРЕВІРКУ ПРИСТРОЮ ПІСЛЯ УСПІШНОГО ЛОГІНУ ***\r\n        // checkDeviceStatus relies on 'user' state, so we need to make sure\r\n        // the state update (setUser) has potentially processed before calling it.\r\n        // Calling it immediately after setUser might work due to state batching\r\n        // or the way useEffect dependencies work, but ensuring 'user' is non-null\r\n        // within checkDeviceStatus handles potential timing issues.\r\n        checkDeviceStatus(); // Викликаємо перевірку пристрою\r\n\r\n        // localStorage вже збережено в LoginPage, але можна зробити це і тут,\r\n        // якщо хочете централізувати логіку збереження після успіху\r\n        // localStorage.setItem('userName', userDataFromLogin.name);\r\n        // localStorage.setItem('isAdmin', userDataFromLogin.is_admin ? 'true' : 'false');\r\n        // console.log('Context: userName and isAdmin saved to localStorage via context.');\r\n\r\n    }, [checkDeviceStatus]); // Залежність від checkDeviceStatus\r\n\r\n\r\n    // Значення контексту, що передається\r\n    const contextValue = {\r\n        user, // null або { name: string }\r\n        isAdmin, // boolean\r\n        hasDevice, // boolean (статус пристрою)\r\n        loadingInitial, // boolean (чи йде початкове завантаження контексту)\r\n        loadingDevice, // boolean (чи йде перевірка пристрою)\r\n        error, // any\r\n        logoutUser, // Функція для виходу\r\n        handleLoginSuccess, // Функція для LoginPage при успішному логіні\r\n        checkDeviceStatus, // Може знадобитись деінде для оновлення статусу пристрою\r\n    };\r\n\r\n    return (\r\n        <UserContext.Provider value={contextValue}>\r\n            {children}\r\n        </UserContext.Provider>\r\n    );\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}