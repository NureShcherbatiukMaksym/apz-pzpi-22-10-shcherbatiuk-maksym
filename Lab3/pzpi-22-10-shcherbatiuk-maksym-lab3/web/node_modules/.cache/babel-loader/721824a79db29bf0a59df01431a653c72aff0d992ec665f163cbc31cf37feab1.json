{"ast":null,"code":"var _jsxFileName = \"D:\\\\Program Files\\\\WebstormProjects\\\\soil_scout\\\\web\\\\src\\\\contexts\\\\UserContext.js\",\n  _s = $RefreshSig$();\n// contexts/UserContext.js\nimport React, { createContext, useState, useEffect, useCallback } from 'react';\nimport api, { setUnauthorizedCallback } from '../utils/api'; // Import setUnauthorizedCallback\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const UserContext = /*#__PURE__*/createContext();\nexport const UserProvider = ({\n  children\n}) => {\n  _s();\n  // Initialize state from localStorage if available, default to null/false\n  const [user, setUser] = useState(() => {\n    const storedUserName = localStorage.getItem('userName');\n    // We can't store the full user object in localStorage easily/securely this way,\n    // just storing the name for display purposes or similar.\n    // A better approach might be to store a user ID or indicate logged in status\n    // and rely on the API to confirm details, but based on your request\n    // we're avoiding /users/me after login.\n    // Let's just store a flag or a basic user identifier if needed, or rely on\n    // the presence of isAdmin/hasDevice flags + cookies for auth status.\n    // For now, setting user to a simple object if userName exists in LS\n    if (storedUserName) {\n      return {\n        name: storedUserName\n      }; // Or null, depending on how 'user' is used\n    }\n    return null;\n  });\n  const [isAdmin, setIsAdmin] = useState(() => localStorage.getItem('isAdmin') === 'true');\n  const [hasDevice, setHasDevice] = useState(false); // Device status always needs verification\n  const [loading, setLoading] = useState(true); // Start as loading to check auth status\n  const [error, setError] = useState(null); // State for potential errors\n\n  // --- Authentication Check and State Initialization on Mount ---\n  // This effect runs once on mount to check if the user is already logged in\n  // (based on cookie/session) and fetch device info.\n  useEffect(() => {\n    const checkAuthAndDevice = async () => {\n      setLoading(true);\n      setError(null);\n\n      // We no longer use /users/me. We check auth status implicitly\n      // by trying to access an authenticated endpoint like /user-iot-devices.\n      try {\n        const devicesRes = await api.get('/user-iot-devices');\n\n        // If the devices endpoint returns success (status 200),\n        // it means the user is authenticated by the backend session/cookie.\n        // We can then set hasDevice based on the response.\n        // We also assume isAdmin and userName might be available in localStorage\n        // from a previous successful login where they were stored.\n        // **IMPORTANT:** Relying solely on localStorage for isAdmin/userName\n        // is potentially insecure. A robust solution would re-verify isAdmin\n        // from the backend on page load if `/users/me` is truly removed.\n        // For this refactor, we'll use localStorage values *if* the\n        // /user-iot-devices call confirms an active session.\n\n        const storedUserName = localStorage.getItem('userName');\n        const storedIsAdmin = localStorage.getItem('isAdmin') === 'true';\n        setUser(storedUserName ? {\n          name: storedUserName\n        } : null); // Set basic user data from LS\n        setIsAdmin(storedIsAdmin);\n        setHasDevice(devicesRes.data && devicesRes.data.length > 0);\n        console.log('Context: Initial auth/device check successful.');\n      } catch (err) {\n        var _err$response;\n        // If the /user-iot-devices call fails with 401, the interceptor handles it\n        // by calling logoutUser, which will clear state and localStorage.\n        // For other errors (network, 500 etc), we should log and ensure state is clear.\n        console.error('Context: Failed initial auth/device check:', err);\n        // If it's not a 401 (which interceptor handles), clear state just in case\n        if (((_err$response = err.response) === null || _err$response === void 0 ? void 0 : _err$response.status) !== 401) {\n          await logoutUser(); // Clear state and localStorage\n        }\n      } finally {\n        setLoading(false); // Finish loading regardless of outcome\n      }\n    };\n    checkAuthAndDevice();\n  }, []); // Empty dependency array means this runs only once on mount\n\n  const logoutUser = useCallback(async () => {\n    // Припускаємо, що у вас є API endpoint для виходу\n    try {\n      await api.post('/auth/logout'); // Замініть на ваш реальний шлях\n      setUser(null);\n      setIsAdmin(false);\n      setHasDevice(false);\n      // Очистити локальне сховище або куки, якщо використовуєте\n      // localStorage.removeItem('token');\n      console.log('User logged out.');\n    } catch (err) {\n      console.error('Failed to log out:', err);\n      // Навіть якщо вихід на бекенді не вдався, очищаємо стан на фронтенді\n      setUser(null);\n      setIsAdmin(false);\n      setHasDevice(false);\n      // Перенаправлення на логін\n      window.location.href = '/login';\n    }\n  }, []);\n\n  // --- Link logoutUser to API interceptor ---\n  useEffect(() => {\n    // Set the logoutUser function to be called by the API interceptor on 401 errors\n    setUnauthorizedCallback(logoutUser);\n\n    // Cleanup function: Remove the callback when the component unmounts or logoutUser changes\n    return () => {\n      setUnauthorizedCallback(null);\n    };\n  }, [logoutUser]); // Dependency ensures callback is updated if logoutUser changes (it won't due to useCallback)\n\n  // --- Function to update context state after successful login ---\n  // LoginPage will call this after successful login AND device check\n  const updateUserStateAfterLogin = useCallback((userData, userHasDevice) => {\n    // userData should contain { name, is_admin } from the login response\n    setUser({\n      name: userData.name\n    }); // Or set the full user object if needed elsewhere\n    setIsAdmin(userData.is_admin || false);\n    setHasDevice(userHasDevice); // This comes from the device check result\n    // Note: localStorage is set directly in LoginPage for now,\n    // could potentially move that logic here too if desired.\n    console.log('Context: State updated after successful login.');\n  }, []);\n\n  // The value provided by the context\n  const contextValue = {\n    user,\n    // Basic user info (name)\n    isAdmin,\n    // Admin status\n    hasDevice,\n    // Device presence status\n    loading,\n    // Is the initial auth/device check loading?\n    error,\n    // Any global error state (currently not heavily used)\n    logoutUser,\n    // Function to perform logout\n    updateUserStateAfterLogin // Function for LoginPage to update state\n  };\n  return /*#__PURE__*/_jsxDEV(UserContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 138,\n    columnNumber: 9\n  }, this);\n};\n_s(UserProvider, \"mUqFIPMifdVq4esmS2aukxtIM3U=\");\n_c = UserProvider;\nvar _c;\n$RefreshReg$(_c, \"UserProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useCallback","api","setUnauthorizedCallback","jsxDEV","_jsxDEV","UserContext","UserProvider","children","_s","user","setUser","storedUserName","localStorage","getItem","name","isAdmin","setIsAdmin","hasDevice","setHasDevice","loading","setLoading","error","setError","checkAuthAndDevice","devicesRes","get","storedIsAdmin","data","length","console","log","err","_err$response","response","status","logoutUser","post","window","location","href","updateUserStateAfterLogin","userData","userHasDevice","is_admin","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/Program Files/WebstormProjects/soil_scout/web/src/contexts/UserContext.js"],"sourcesContent":["// contexts/UserContext.js\r\nimport React, { createContext, useState, useEffect, useCallback } from 'react';\r\nimport api, { setUnauthorizedCallback } from '../utils/api'; // Import setUnauthorizedCallback\r\n\r\nexport const UserContext = createContext();\r\n\r\nexport const UserProvider = ({ children }) => {\r\n    // Initialize state from localStorage if available, default to null/false\r\n    const [user, setUser] = useState(() => {\r\n        const storedUserName = localStorage.getItem('userName');\r\n        // We can't store the full user object in localStorage easily/securely this way,\r\n        // just storing the name for display purposes or similar.\r\n        // A better approach might be to store a user ID or indicate logged in status\r\n        // and rely on the API to confirm details, but based on your request\r\n        // we're avoiding /users/me after login.\r\n        // Let's just store a flag or a basic user identifier if needed, or rely on\r\n        // the presence of isAdmin/hasDevice flags + cookies for auth status.\r\n        // For now, setting user to a simple object if userName exists in LS\r\n        if (storedUserName) {\r\n            return { name: storedUserName }; // Or null, depending on how 'user' is used\r\n        }\r\n        return null;\r\n    });\r\n    const [isAdmin, setIsAdmin] = useState(() => localStorage.getItem('isAdmin') === 'true');\r\n    const [hasDevice, setHasDevice] = useState(false); // Device status always needs verification\r\n    const [loading, setLoading] = useState(true); // Start as loading to check auth status\r\n    const [error, setError] = useState(null); // State for potential errors\r\n\r\n    // --- Authentication Check and State Initialization on Mount ---\r\n    // This effect runs once on mount to check if the user is already logged in\r\n    // (based on cookie/session) and fetch device info.\r\n    useEffect(() => {\r\n        const checkAuthAndDevice = async () => {\r\n            setLoading(true);\r\n            setError(null);\r\n\r\n            // We no longer use /users/me. We check auth status implicitly\r\n            // by trying to access an authenticated endpoint like /user-iot-devices.\r\n            try {\r\n                const devicesRes = await api.get('/user-iot-devices');\r\n\r\n                // If the devices endpoint returns success (status 200),\r\n                // it means the user is authenticated by the backend session/cookie.\r\n                // We can then set hasDevice based on the response.\r\n                // We also assume isAdmin and userName might be available in localStorage\r\n                // from a previous successful login where they were stored.\r\n                // **IMPORTANT:** Relying solely on localStorage for isAdmin/userName\r\n                // is potentially insecure. A robust solution would re-verify isAdmin\r\n                // from the backend on page load if `/users/me` is truly removed.\r\n                // For this refactor, we'll use localStorage values *if* the\r\n                // /user-iot-devices call confirms an active session.\r\n\r\n                const storedUserName = localStorage.getItem('userName');\r\n                const storedIsAdmin = localStorage.getItem('isAdmin') === 'true';\r\n\r\n                setUser(storedUserName ? { name: storedUserName } : null); // Set basic user data from LS\r\n                setIsAdmin(storedIsAdmin);\r\n                setHasDevice(devicesRes.data && devicesRes.data.length > 0);\r\n\r\n                console.log('Context: Initial auth/device check successful.');\r\n\r\n            } catch (err) {\r\n                // If the /user-iot-devices call fails with 401, the interceptor handles it\r\n                // by calling logoutUser, which will clear state and localStorage.\r\n                // For other errors (network, 500 etc), we should log and ensure state is clear.\r\n                console.error('Context: Failed initial auth/device check:', err);\r\n                // If it's not a 401 (which interceptor handles), clear state just in case\r\n                if (err.response?.status !== 401) {\r\n                    await logoutUser(); // Clear state and localStorage\r\n                }\r\n            } finally {\r\n                setLoading(false); // Finish loading regardless of outcome\r\n            }\r\n        };\r\n\r\n        checkAuthAndDevice();\r\n    }, []); // Empty dependency array means this runs only once on mount\r\n\r\n    const logoutUser = useCallback(async () => {\r\n        // Припускаємо, що у вас є API endpoint для виходу\r\n        try {\r\n            await api.post('/auth/logout'); // Замініть на ваш реальний шлях\r\n            setUser(null);\r\n            setIsAdmin(false);\r\n            setHasDevice(false);\r\n            // Очистити локальне сховище або куки, якщо використовуєте\r\n            // localStorage.removeItem('token');\r\n            console.log('User logged out.');\r\n        } catch (err) {\r\n            console.error('Failed to log out:', err);\r\n            // Навіть якщо вихід на бекенді не вдався, очищаємо стан на фронтенді\r\n            setUser(null);\r\n            setIsAdmin(false);\r\n            setHasDevice(false);\r\n            // Перенаправлення на логін\r\n            window.location.href = '/login';\r\n        }\r\n    }, []);\r\n\r\n\r\n    // --- Link logoutUser to API interceptor ---\r\n    useEffect(() => {\r\n        // Set the logoutUser function to be called by the API interceptor on 401 errors\r\n        setUnauthorizedCallback(logoutUser);\r\n\r\n        // Cleanup function: Remove the callback when the component unmounts or logoutUser changes\r\n        return () => {\r\n            setUnauthorizedCallback(null);\r\n        };\r\n    }, [logoutUser]); // Dependency ensures callback is updated if logoutUser changes (it won't due to useCallback)\r\n\r\n\r\n    // --- Function to update context state after successful login ---\r\n    // LoginPage will call this after successful login AND device check\r\n    const updateUserStateAfterLogin = useCallback((userData, userHasDevice) => {\r\n        // userData should contain { name, is_admin } from the login response\r\n        setUser({ name: userData.name }); // Or set the full user object if needed elsewhere\r\n        setIsAdmin(userData.is_admin || false);\r\n        setHasDevice(userHasDevice); // This comes from the device check result\r\n        // Note: localStorage is set directly in LoginPage for now,\r\n        // could potentially move that logic here too if desired.\r\n        console.log('Context: State updated after successful login.');\r\n    }, []);\r\n\r\n\r\n    // The value provided by the context\r\n    const contextValue = {\r\n        user, // Basic user info (name)\r\n        isAdmin, // Admin status\r\n        hasDevice, // Device presence status\r\n        loading, // Is the initial auth/device check loading?\r\n        error, // Any global error state (currently not heavily used)\r\n        logoutUser, // Function to perform logout\r\n        updateUserStateAfterLogin, // Function for LoginPage to update state\r\n    };\r\n\r\n    return (\r\n        <UserContext.Provider value={contextValue}>\r\n            {children}\r\n        </UserContext.Provider>\r\n    );\r\n};"],"mappings":";;AAAA;AACA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,WAAW,QAAQ,OAAO;AAC9E,OAAOC,GAAG,IAAIC,uBAAuB,QAAQ,cAAc,CAAC,CAAC;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAE7D,OAAO,MAAMC,WAAW,gBAAGR,aAAa,CAAC,CAAC;AAE1C,OAAO,MAAMS,YAAY,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EAAAC,EAAA;EAC1C;EACA,MAAM,CAACC,IAAI,EAAEC,OAAO,CAAC,GAAGZ,QAAQ,CAAC,MAAM;IACnC,MAAMa,cAAc,GAAGC,YAAY,CAACC,OAAO,CAAC,UAAU,CAAC;IACvD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIF,cAAc,EAAE;MAChB,OAAO;QAAEG,IAAI,EAAEH;MAAe,CAAC,CAAC,CAAC;IACrC;IACA,OAAO,IAAI;EACf,CAAC,CAAC;EACF,MAAM,CAACI,OAAO,EAAEC,UAAU,CAAC,GAAGlB,QAAQ,CAAC,MAAMc,YAAY,CAACC,OAAO,CAAC,SAAS,CAAC,KAAK,MAAM,CAAC;EACxF,MAAM,CAACI,SAAS,EAAEC,YAAY,CAAC,GAAGpB,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;EACnD,MAAM,CAACqB,OAAO,EAAEC,UAAU,CAAC,GAAGtB,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;EAC9C,MAAM,CAACuB,KAAK,EAAEC,QAAQ,CAAC,GAAGxB,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;;EAE1C;EACA;EACA;EACAC,SAAS,CAAC,MAAM;IACZ,MAAMwB,kBAAkB,GAAG,MAAAA,CAAA,KAAY;MACnCH,UAAU,CAAC,IAAI,CAAC;MAChBE,QAAQ,CAAC,IAAI,CAAC;;MAEd;MACA;MACA,IAAI;QACA,MAAME,UAAU,GAAG,MAAMvB,GAAG,CAACwB,GAAG,CAAC,mBAAmB,CAAC;;QAErD;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA,MAAMd,cAAc,GAAGC,YAAY,CAACC,OAAO,CAAC,UAAU,CAAC;QACvD,MAAMa,aAAa,GAAGd,YAAY,CAACC,OAAO,CAAC,SAAS,CAAC,KAAK,MAAM;QAEhEH,OAAO,CAACC,cAAc,GAAG;UAAEG,IAAI,EAAEH;QAAe,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;QAC3DK,UAAU,CAACU,aAAa,CAAC;QACzBR,YAAY,CAACM,UAAU,CAACG,IAAI,IAAIH,UAAU,CAACG,IAAI,CAACC,MAAM,GAAG,CAAC,CAAC;QAE3DC,OAAO,CAACC,GAAG,CAAC,gDAAgD,CAAC;MAEjE,CAAC,CAAC,OAAOC,GAAG,EAAE;QAAA,IAAAC,aAAA;QACV;QACA;QACA;QACAH,OAAO,CAACR,KAAK,CAAC,4CAA4C,EAAEU,GAAG,CAAC;QAChE;QACA,IAAI,EAAAC,aAAA,GAAAD,GAAG,CAACE,QAAQ,cAAAD,aAAA,uBAAZA,aAAA,CAAcE,MAAM,MAAK,GAAG,EAAE;UAC9B,MAAMC,UAAU,CAAC,CAAC,CAAC,CAAC;QACxB;MACJ,CAAC,SAAS;QACNf,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;MACvB;IACJ,CAAC;IAEDG,kBAAkB,CAAC,CAAC;EACxB,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;;EAER,MAAMY,UAAU,GAAGnC,WAAW,CAAC,YAAY;IACvC;IACA,IAAI;MACA,MAAMC,GAAG,CAACmC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;MAChC1B,OAAO,CAAC,IAAI,CAAC;MACbM,UAAU,CAAC,KAAK,CAAC;MACjBE,YAAY,CAAC,KAAK,CAAC;MACnB;MACA;MACAW,OAAO,CAACC,GAAG,CAAC,kBAAkB,CAAC;IACnC,CAAC,CAAC,OAAOC,GAAG,EAAE;MACVF,OAAO,CAACR,KAAK,CAAC,oBAAoB,EAAEU,GAAG,CAAC;MACxC;MACArB,OAAO,CAAC,IAAI,CAAC;MACbM,UAAU,CAAC,KAAK,CAAC;MACjBE,YAAY,CAAC,KAAK,CAAC;MACnB;MACAmB,MAAM,CAACC,QAAQ,CAACC,IAAI,GAAG,QAAQ;IACnC;EACJ,CAAC,EAAE,EAAE,CAAC;;EAGN;EACAxC,SAAS,CAAC,MAAM;IACZ;IACAG,uBAAuB,CAACiC,UAAU,CAAC;;IAEnC;IACA,OAAO,MAAM;MACTjC,uBAAuB,CAAC,IAAI,CAAC;IACjC,CAAC;EACL,CAAC,EAAE,CAACiC,UAAU,CAAC,CAAC,CAAC,CAAC;;EAGlB;EACA;EACA,MAAMK,yBAAyB,GAAGxC,WAAW,CAAC,CAACyC,QAAQ,EAAEC,aAAa,KAAK;IACvE;IACAhC,OAAO,CAAC;MAAEI,IAAI,EAAE2B,QAAQ,CAAC3B;IAAK,CAAC,CAAC,CAAC,CAAC;IAClCE,UAAU,CAACyB,QAAQ,CAACE,QAAQ,IAAI,KAAK,CAAC;IACtCzB,YAAY,CAACwB,aAAa,CAAC,CAAC,CAAC;IAC7B;IACA;IACAb,OAAO,CAACC,GAAG,CAAC,gDAAgD,CAAC;EACjE,CAAC,EAAE,EAAE,CAAC;;EAGN;EACA,MAAMc,YAAY,GAAG;IACjBnC,IAAI;IAAE;IACNM,OAAO;IAAE;IACTE,SAAS;IAAE;IACXE,OAAO;IAAE;IACTE,KAAK;IAAE;IACPc,UAAU;IAAE;IACZK,yBAAyB,CAAE;EAC/B,CAAC;EAED,oBACIpC,OAAA,CAACC,WAAW,CAACwC,QAAQ;IAACC,KAAK,EAAEF,YAAa;IAAArC,QAAA,EACrCA;EAAQ;IAAAwC,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACS,CAAC;AAE/B,CAAC;AAAC1C,EAAA,CAvIWF,YAAY;AAAA6C,EAAA,GAAZ7C,YAAY;AAAA,IAAA6C,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}