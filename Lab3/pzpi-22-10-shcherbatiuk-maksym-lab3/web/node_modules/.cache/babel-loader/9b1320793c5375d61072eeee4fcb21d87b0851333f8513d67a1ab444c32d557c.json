{"ast":null,"code":"var _jsxFileName = \"D:\\\\Program Files\\\\WebstormProjects\\\\soil_scout\\\\web\\\\src\\\\contexts\\\\UserContext.js\",\n  _s = $RefreshSig$();\n// contexts/UserContext.js\nimport React, { createContext, useState, useEffect, useCallback } from 'react';\n// Імпортуємо обидві функції\nimport { setUnauthorizedCallback, setIsLoggingOut } from '../utils/api';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const UserContext = /*#__PURE__*/createContext();\nexport const UserProvider = ({\n  children\n}) => {\n  _s();\n  // Початковий стан: Відображаємо дані з localStorage, але не робимо API виклик при монтуванні\n  const [user, setUser] = useState(() => {\n    const storedUserName = localStorage.getItem('userName');\n    // Присутність userName в localStorage не гарантує автентифікацію, але може використовуватись для відображення\n    return storedUserName ? {\n      name: storedUserName\n    } : null;\n  });\n  const [isAdmin, setIsAdmin] = useState(() => localStorage.getItem('isAdmin') === 'true');\n  const [hasDevice, setHasDevice] = useState(false); // Статус пристрою завжди потребує перевірки після логіну\n  // Initial loading state should be false, as we don't check auth on mount anymore\n  // Можете залишити loading: true, якщо ваша App структура чекає чогось іншого\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // --- Початкова перевірка автентифікації ВИДАЛЕНА ---\n  // useEffect, який робив запит /user-iot-devices при монтуванні, тут більше немає.\n  // Автентифікація буде перевірятися при першому запиті, який зробить компонент.\n\n  // --- Логіка Виходу ---\n  // Ця функція викликається перехоплювачем (при 401) або компонентами (наприклад, кнопка \"Вийти\")\n  const logoutUser = useCallback(async () => {\n    console.log('Context: logoutUser called.');\n\n    // Прапорець isLoggingOut встановлюється в true перехоплювачем ПЕРЕД викликом цієї функції.\n    // Якщо функція викликана компонентом напряму (наприклад, кнопкою), встановлюємо його тут:\n    // setIsLoggingOut(true); // Можна розкоментувати, якщо викликаєте напряму з компонентів, але перехоплювач вже це робить.\n\n    // Опціонально: викликаємо endpoint для виходу на бекенді\n    // Важливо, щоб цей endpoint не повертав 401, який знову спрацює в перехоплювачі.\n    // Або перехоплювач має ігнорувати 401, коли isLoggingOut === true.\n    try {\n      console.log('Context: Attempting backend /auth/logout call (optional)...');\n      // await api.post('/auth/logout'); // Розкоментуйте, якщо маєте такий endpoint\n      console.log('Context: Backend logout call finished (or skipped).');\n    } catch (err) {\n      console.error('Context: Failed to call backend logout API:', err);\n      // Продовжуємо очищення стану, навіть якщо бекенд-виклик не вдався\n    } finally {\n      // --- Очищення стану та localStorage ---\n      console.log('Context: Performing local logout cleanup.');\n      setUser(null);\n      setIsAdmin(false);\n      setHasDevice(false);\n      localStorage.removeItem('userName');\n      localStorage.removeItem('isAdmin');\n      // localStorage.removeItem('token'); // Розкоментуйте, якщо зберігаєте токен у localStorage\n\n      // *** СКИНУТИ прапорець isLoggingOut ПІСЛЯ очищення стану/localStorage ***\n      // Це дозволить перехоплювачу реагувати на 401 знову, якщо вони виникнуть після повного виходу\n      setIsLoggingOut(false);\n      console.log('Context: logoutUser finished, setIsLoggingOut(false).');\n\n      // *** ВАЖЛИВО: Перенаправлення на /login сторінку відбувається в компоненті App (або роутері),\n      // який спостерігає за зміною стану 'user' на null. ***\n      // window.location.href = '/login'; // <-- ЦЕ ПРИБРАНО\n    }\n  }, []); // Немає залежностей, оскільки localLogout також не має залежностей і обгорнутий в useCallback\n\n  // --- Зв'язуємо logoutUser з перехоплювачем API ---\n  useEffect(() => {\n    console.log('Context: Setting API unauthorized callback.');\n    // Передаємо функцію logoutUser, яка буде викликана перехоплювачем при 401\n    setUnauthorizedCallback(logoutUser);\n\n    // Функція очищення: скидаємо callback при демонтажі компонента або зміні logoutUser\n    return () => {\n      console.log('Context: Clearing API unauthorized callback.');\n      setUnauthorizedCallback(null);\n      // Також скидаємо прапорець isLoggingOut при демонтажі контексту\n      setIsLoggingOut(false);\n    };\n  }, [logoutUser]); // Залежність від logoutUser (яка обгорнута в useCallback)\n\n  // --- Функція для оновлення стану контексту ПІСЛЯ успішного логіну ТА перевірки пристроїв ---\n  // Цю функцію викликає LoginPage тільки після того, як обидва кроки пройшли успішно\n  const updateUserStateAfterLogin = useCallback(userData => {\n    console.log('Context: updateUserStateAfterLogin called.');\n    // userData має містити { name, is_admin } з відповіді логіну\n    // Ми знаємо, що пристрій є, бо LoginPage це перевірив\n    setUser({\n      name: userData.name\n    });\n    setIsAdmin(userData.is_admin || false);\n    setHasDevice(true); // Встановлюємо в true, оскільки LoginPage підтвердив наявність пристрою\n    // Зберігання у localStorage відбувається в LoginPage після перевірки пристроїв.\n    setError(null); // Очищаємо помилки\n  }, []);\n\n  // Значення контексту, що передається дочірнім компонентам\n  const contextValue = {\n    user,\n    // null або { name: string }\n    isAdmin,\n    // boolean\n    hasDevice,\n    // boolean\n    loading,\n    // boolean (менш критично зараз)\n    error,\n    // any (глобально не heavily used)\n    logoutUser,\n    // Функція для виконання виходу (викликається перехоплювачем або компонентами)\n    updateUserStateAfterLogin // Функція для LoginPage для оновлення стану після повного успіху\n    // setIsLoggingOut не передаємо через контекст, керуємо ним внутрішньо або через api.js експорт\n  };\n  return /*#__PURE__*/_jsxDEV(UserContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 110,\n    columnNumber: 9\n  }, this);\n};\n_s(UserProvider, \"s4QUXETPva7fZ1UYXwDcFjSgi8Q=\");\n_c = UserProvider;\nvar _c;\n$RefreshReg$(_c, \"UserProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useCallback","setUnauthorizedCallback","setIsLoggingOut","jsxDEV","_jsxDEV","UserContext","UserProvider","children","_s","user","setUser","storedUserName","localStorage","getItem","name","isAdmin","setIsAdmin","hasDevice","setHasDevice","loading","setLoading","error","setError","logoutUser","console","log","err","removeItem","updateUserStateAfterLogin","userData","is_admin","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/Program Files/WebstormProjects/soil_scout/web/src/contexts/UserContext.js"],"sourcesContent":["// contexts/UserContext.js\r\nimport React, { createContext, useState, useEffect, useCallback } from 'react';\r\n// Імпортуємо обидві функції\r\nimport { setUnauthorizedCallback, setIsLoggingOut } from '../utils/api';\r\n\r\nexport const UserContext = createContext();\r\n\r\nexport const UserProvider = ({ children }) => {\r\n    // Початковий стан: Відображаємо дані з localStorage, але не робимо API виклик при монтуванні\r\n    const [user, setUser] = useState(() => {\r\n        const storedUserName = localStorage.getItem('userName');\r\n        // Присутність userName в localStorage не гарантує автентифікацію, але може використовуватись для відображення\r\n        return storedUserName ? { name: storedUserName } : null;\r\n    });\r\n    const [isAdmin, setIsAdmin] = useState(() => localStorage.getItem('isAdmin') === 'true');\r\n    const [hasDevice, setHasDevice] = useState(false); // Статус пристрою завжди потребує перевірки після логіну\r\n    // Initial loading state should be false, as we don't check auth on mount anymore\r\n    // Можете залишити loading: true, якщо ваша App структура чекає чогось іншого\r\n    const [loading, setLoading] = useState(false);\r\n    const [error, setError] = useState(null);\r\n\r\n    // --- Початкова перевірка автентифікації ВИДАЛЕНА ---\r\n    // useEffect, який робив запит /user-iot-devices при монтуванні, тут більше немає.\r\n    // Автентифікація буде перевірятися при першому запиті, який зробить компонент.\r\n\r\n    // --- Логіка Виходу ---\r\n    // Ця функція викликається перехоплювачем (при 401) або компонентами (наприклад, кнопка \"Вийти\")\r\n    const logoutUser = useCallback(async () => {\r\n        console.log('Context: logoutUser called.');\r\n\r\n        // Прапорець isLoggingOut встановлюється в true перехоплювачем ПЕРЕД викликом цієї функції.\r\n        // Якщо функція викликана компонентом напряму (наприклад, кнопкою), встановлюємо його тут:\r\n        // setIsLoggingOut(true); // Можна розкоментувати, якщо викликаєте напряму з компонентів, але перехоплювач вже це робить.\r\n\r\n        // Опціонально: викликаємо endpoint для виходу на бекенді\r\n        // Важливо, щоб цей endpoint не повертав 401, який знову спрацює в перехоплювачі.\r\n        // Або перехоплювач має ігнорувати 401, коли isLoggingOut === true.\r\n        try {\r\n            console.log('Context: Attempting backend /auth/logout call (optional)...');\r\n            // await api.post('/auth/logout'); // Розкоментуйте, якщо маєте такий endpoint\r\n            console.log('Context: Backend logout call finished (or skipped).');\r\n        } catch (err) {\r\n            console.error('Context: Failed to call backend logout API:', err);\r\n            // Продовжуємо очищення стану, навіть якщо бекенд-виклик не вдався\r\n        } finally {\r\n            // --- Очищення стану та localStorage ---\r\n            console.log('Context: Performing local logout cleanup.');\r\n            setUser(null);\r\n            setIsAdmin(false);\r\n            setHasDevice(false);\r\n            localStorage.removeItem('userName');\r\n            localStorage.removeItem('isAdmin');\r\n            // localStorage.removeItem('token'); // Розкоментуйте, якщо зберігаєте токен у localStorage\r\n\r\n            // *** СКИНУТИ прапорець isLoggingOut ПІСЛЯ очищення стану/localStorage ***\r\n            // Це дозволить перехоплювачу реагувати на 401 знову, якщо вони виникнуть після повного виходу\r\n            setIsLoggingOut(false);\r\n            console.log('Context: logoutUser finished, setIsLoggingOut(false).');\r\n\r\n            // *** ВАЖЛИВО: Перенаправлення на /login сторінку відбувається в компоненті App (або роутері),\r\n            // який спостерігає за зміною стану 'user' на null. ***\r\n            // window.location.href = '/login'; // <-- ЦЕ ПРИБРАНО\r\n        }\r\n    }, []); // Немає залежностей, оскільки localLogout також не має залежностей і обгорнутий в useCallback\r\n\r\n\r\n    // --- Зв'язуємо logoutUser з перехоплювачем API ---\r\n    useEffect(() => {\r\n        console.log('Context: Setting API unauthorized callback.');\r\n        // Передаємо функцію logoutUser, яка буде викликана перехоплювачем при 401\r\n        setUnauthorizedCallback(logoutUser);\r\n\r\n        // Функція очищення: скидаємо callback при демонтажі компонента або зміні logoutUser\r\n        return () => {\r\n            console.log('Context: Clearing API unauthorized callback.');\r\n            setUnauthorizedCallback(null);\r\n            // Також скидаємо прапорець isLoggingOut при демонтажі контексту\r\n            setIsLoggingOut(false);\r\n        };\r\n    }, [logoutUser]); // Залежність від logoutUser (яка обгорнута в useCallback)\r\n\r\n\r\n    // --- Функція для оновлення стану контексту ПІСЛЯ успішного логіну ТА перевірки пристроїв ---\r\n    // Цю функцію викликає LoginPage тільки після того, як обидва кроки пройшли успішно\r\n    const updateUserStateAfterLogin = useCallback((userData) => {\r\n        console.log('Context: updateUserStateAfterLogin called.');\r\n        // userData має містити { name, is_admin } з відповіді логіну\r\n        // Ми знаємо, що пристрій є, бо LoginPage це перевірив\r\n        setUser({ name: userData.name });\r\n        setIsAdmin(userData.is_admin || false);\r\n        setHasDevice(true); // Встановлюємо в true, оскільки LoginPage підтвердив наявність пристрою\r\n        // Зберігання у localStorage відбувається в LoginPage після перевірки пристроїв.\r\n        setError(null); // Очищаємо помилки\r\n    }, []);\r\n\r\n\r\n    // Значення контексту, що передається дочірнім компонентам\r\n    const contextValue = {\r\n        user, // null або { name: string }\r\n        isAdmin, // boolean\r\n        hasDevice, // boolean\r\n        loading, // boolean (менш критично зараз)\r\n        error, // any (глобально не heavily used)\r\n        logoutUser, // Функція для виконання виходу (викликається перехоплювачем або компонентами)\r\n        updateUserStateAfterLogin, // Функція для LoginPage для оновлення стану після повного успіху\r\n        // setIsLoggingOut не передаємо через контекст, керуємо ним внутрішньо або через api.js експорт\r\n    };\r\n\r\n    return (\r\n        <UserContext.Provider value={contextValue}>\r\n            {children}\r\n        </UserContext.Provider>\r\n    );\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}