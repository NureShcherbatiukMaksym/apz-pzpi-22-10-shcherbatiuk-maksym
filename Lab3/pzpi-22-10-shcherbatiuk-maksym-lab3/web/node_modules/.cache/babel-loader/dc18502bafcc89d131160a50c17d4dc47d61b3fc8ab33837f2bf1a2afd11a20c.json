{"ast":null,"code":"var _jsxFileName = \"D:\\\\Program Files\\\\WebstormProjects\\\\soil_scout\\\\web\\\\src\\\\contexts\\\\UserContext.js\",\n  _s = $RefreshSig$();\n// contexts/UserContext.js\nimport React, { createContext, useState, useEffect, useCallback, useRef } from 'react'; // Додано useRef\n// Імпортуємо лише setUnauthorizedCallback\nimport api, { setUnauthorizedCallback } from '../utils/api'; // ВИДАЛЕНО: setIsLoggingOut\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const UserContext = /*#__PURE__*/createContext();\nexport const UserProvider = ({\n  children\n}) => {\n  _s();\n  // --- ОНОВЛЕНО: Початковий стан: ініціалізуємо з УСІХ даних localStorage, включаючи profile_picture_url, id, isAdmin ---\n  const [user, setUser] = useState(() => {\n    try {\n      // Додано try/catch на випадок помилок парсингу localStorage\n      const storedUserId = localStorage.getItem('userId');\n      const storedUserName = localStorage.getItem('userName');\n      const storedIsAdmin = localStorage.getItem('isAdmin') === 'true';\n      const storedProfilePictureUrl = localStorage.getItem('userProfilePictureUrl'); // <-- Читаємо URL фото\n\n      // Повертаємо повний об'єкт, якщо є мінімальні дані\n      if (storedUserId && storedUserName !== null) {\n        // Перевіряємо userName на null явно\n        console.log('Context: Initializing user from localStorage:', {\n          storedUserId,\n          storedUserName,\n          storedIsAdmin,\n          storedProfilePictureUrl\n        });\n        return {\n          id: storedUserId,\n          name: storedUserName,\n          is_admin: storedIsAdmin,\n          profile_picture_url: storedProfilePictureUrl || null // Включаємо URL\n          // TODO: Можливо, додати інші поля, які можуть зберігатись у LS при логіні/верифікації\n        };\n      }\n    } catch (e) {\n      console.error(\"Context: Error reading user data from localStorage\", e);\n      // Очистити localStorage, якщо сталося помилка\n      localStorage.removeItem('userId');\n      localStorage.removeItem('userName');\n      localStorage.removeItem('isAdmin');\n      localStorage.removeItem('userProfilePictureUrl');\n    }\n    return null; // Якщо даних у localStorage немає або помилка\n  });\n\n  // isAdmin та userId тепер ПОВИННІ братися з об'єкта user, або оновлюватися разом з ним.\n  // Краще брати їх з user, але якщо вони використовуються окремо, оновлюйте їх в setUser колбеках.\n  // Залишаємо їх окремо, але будемо синхронізувати.\n  const [isAdmin, setIsAdmin] = useState(() => localStorage.getItem('isAdmin') === 'true');\n  const [userId, setUserId] = useState(() => localStorage.getItem('userId'));\n  const [hasDevice, setHasDevice] = useState(false);\n  const [loadingDevice, setLoadingDevice] = useState(false);\n  const [loadingInitial, setLoadingInitial] = useState(true);\n  const [error, setError] = useState(null);\n  const isInitialCheckDone = useRef(false);\n\n  // --- Функція перевірки наявності пристрою ---\n  // Ця функція не має залежати від loadingDevice для свого useCallback,\n  // оскільки вона сама керує цим станом. Вона залежить від `user`.\n  const checkDeviceStatus = useCallback(async currentUser => {\n    // Робимо перевірку лише якщо користувач виглядає залогіненим (присутній user об'єкт)\n    // і ми ще не перевіряємо його пристрій\n    // Використовуємо аргумент currentUser, який передається (або беремо поточний user зі scope)\n    if (!currentUser) {\n      console.log('Context: checkDeviceStatus skipped - user is null.');\n      setHasDevice(false); // Якщо user = null, пристрою точно немає\n      // setLoadingDevice(false); // Переконаємося, що loadingDevice також false\n      return; // Не виконуємо запит\n    }\n    // Перевіряємо loadingDevice тут, щоб уникнути повторних викликів, якщо вони якось накладаються\n    if (loadingDevice) {\n      console.log('Context: checkDeviceStatus skipped - already checking.');\n      return;\n    }\n    setLoadingDevice(true);\n    console.log('Context: Performing device status check...');\n    try {\n      const devicesRes = await api.get('/user-iot-devices');\n      const userHasDevice = devicesRes.data && devicesRes.data.length > 0;\n      setHasDevice(userHasDevice);\n      console.log(`Context: Device check successful. Has device: ${userHasDevice}.`);\n      // setError(null);\n    } catch (err) {\n      var _err$response;\n      console.error('Context: Failed to fetch user devices:', err);\n      // Перехоплювач обробить 401 і викличе logoutUser.\n      // Для інших помилок, вважаємо, що пристрій недоступний у цей момент.\n      if (((_err$response = err.response) === null || _err$response === void 0 ? void 0 : _err$response.status) !== 401) {\n        setHasDevice(false); // Встановлюємо false при інших помилках\n        // setError(err); // Можна встановити помилку\n      }\n    } finally {\n      setLoadingDevice(false);\n    }\n  }, [user]); // Залежність тільки від user\n\n  // --- Початкова перевірка при монтуванні ---\n  // Використовуємо реф, щоб переконатися, що цей ефект виконується лише один раз\n  useEffect(() => {\n    if (isInitialCheckDone.current) {\n      console.log('Context: Initial check already done, skipping useEffect.');\n      return;\n    }\n    isInitialCheckDone.current = true;\n    console.log('Context: Starting initial check useEffect.');\n\n    // Стан user вже ініціалізовано з localStorage перед useEffect\n    const initialUserFromState = user;\n    const verifyAuthAndFetchUserData = async () => {\n      setLoadingInitial(true); // Ставимо loadingInitial в true перед запитом\n\n      try {\n        // Викликаємо ендпоінт для отримання даних поточного користувача.\n        // Переконайтесь, що /auth/me повертає ПОВНИЙ об'єкт користувача (id, name, is_admin, profile_picture_url).\n        const res = await api.get('/auth/me', {\n          withCredentials: true\n        });\n        const fetchedUser = res.data.user; // Припускаємо, що дані користувача вкладені у 'user'\n\n        if (fetchedUser && fetchedUser.id) {\n          // Перевіряємо, що об'єкт користувача та його ID валідні\n          console.log('UserContext: Backend auth verification successful, user data fetched:', fetchedUser);\n          // !!! КОРЕКЦІЯ: ОНОВЛЮЄМО СТАН КОРИСТУВАЧА ПОВНИМ ОБ'ЄКТОМ З БЕКЕНДУ !!!\n          setUser(fetchedUser); // Це оновить user (включаючи id, name, is_admin, profile_picture_url)\n\n          // Синхронізуємо isAdmin та userId стани\n          setIsAdmin(fetchedUser.is_admin || false);\n          setUserId(fetchedUser.id);\n\n          // ОНОВЛЮЄМО localStorage СВІЖИМИ ДАНИМИ\n          localStorage.setItem('userId', fetchedUser.id);\n          localStorage.setItem('userName', fetchedUser.name);\n          localStorage.setItem('isAdmin', fetchedUser.is_admin ? 'true' : 'false');\n          if (fetchedUser.profile_picture_url) {\n            localStorage.setItem('userProfilePictureUrl', fetchedUser.profile_picture_url);\n            console.log('UserContext: Fresh profile picture URL saved to localStorage:', fetchedUser.profile_picture_url);\n          } else {\n            localStorage.removeItem('userProfilePictureUrl');\n            console.log('UserContext: No fresh profile picture URL received, removed from localStorage.');\n          }\n\n          // Запускаємо перевірку статусу пристрою з отриманими даними користувача\n          checkDeviceStatus(fetchedUser);\n        } else {\n          console.log('UserContext: Backend auth verification failed (no user data), logging out locally.');\n          // Якщо бекенд не повернув користувача або повернув невалідний об'єкт,\n          // виконуємо локальний вихід.\n          logoutUser();\n        }\n      } catch (error) {\n        var _error$response;\n        console.error('UserContext: Auth verification API error:', error);\n        // Перехоплювач обробить 401. Для інших помилок:\n        if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) !== 401) {\n          console.log('UserContext: Verification failed due to non-401 error, performing local logout.');\n          logoutUser(); // Локальний вихід при інших помилках запиту\n        }\n        // Якщо помилка 401, перехоплювач викличе logoutUser\n      } finally {\n        setLoadingInitial(false); // Початкове завантаження завершено після спроби верифікації\n        console.log('Context: Initial auth verification process finished.');\n      }\n    };\n\n    // Запускаємо процес верифікації, тільки якщо є якісь ознаки логіну в localStorage\n    // (тобто, якщо початковий стан user НЕ null)\n    if (initialUserFromState) {\n      console.log('UserContext: Initial user data found in localStorage, starting verification.');\n      verifyAuthAndFetchUserData();\n    } else {\n      // Немає початкових даних користувача в localStorage, верифікація не потрібна.\n      // Початкове завантаження завершено негайно.\n      console.log('Context: No initial user data, skipping verification.');\n      setLoadingInitial(false);\n      setHasDevice(false); // Переконаємося, що статус пристрою false\n    }\n  }, [checkDeviceStatus, logoutUser]); // Залежності ефекту\n\n  // --- Логіка Виходу ---\n  const logoutUser = useCallback(async () => {\n    console.log('Context: logoutUser called.');\n\n    // Опціонально: викликаємо endpoint для виходу на бекенді\n    // !!! ВАЖЛИВО: цей endpoint НЕ ПОВИНЕН повертати 401, який знову спрацює в перехоплювачі,\n    // коли сесія вже недійсна. Повинен повертати 200 або інший статус.\n    try {\n      console.log('Context: Attempting backend /auth/logout call (optional)...');\n      // await api.post('/auth/logout'); // Розкоментуйте, якщо маєте такий endpoint\n      console.log('Context: Backend logout call finished (or skipped).');\n    } catch (err) {\n      console.error('Context: Failed to call backend logout API:', err);\n    } finally {\n      // --- Очищення стану та localStorage ---\n      console.log('Context: Performing local logout cleanup.');\n      setUser(null);\n      setIsAdmin(false);\n      setHasDevice(false); // При виході пристрою точно немає\n      setLoadingDevice(false); // При виході скасовуємо будь-яке завантаження пристрою\n      localStorage.removeItem('userName');\n      localStorage.removeItem('isAdmin');\n      localStorage.removeItem('userProfilePictureUrl'); // <-- Видаляємо URL фото з localStorage\n\n      // localStorage.removeItem('token'); // Розкоментуйте, якщо зберігаєте токен у localStorage\n\n      // *** Немає isLoggingOut прапорця для скидання ***\n\n      // *** ВАЖЛИВО: Перенаправлення на /login сторінку відбувається в App (або роутері),\n      // який спостерігає за зміною стану 'user' на null. ***\n    }\n  }, []);\n\n  // --- Зв'язуємо logoutUser з перехоплювачем API ---\n  useEffect(() => {\n    console.log('Context: Setting API unauthorized callback.');\n    setUnauthorizedCallback(logoutUser);\n    return () => {\n      console.log('Context: Clearing API unauthorized callback.');\n      setUnauthorizedCallback(null);\n    };\n  }, [logoutUser]);\n\n  // --- Функція для обробки успіху логіну (викликається з LoginPage) ---\n  const handleLoginSuccess = useCallback(userDataFromLogin => {\n    console.log('Context: handleLoginSuccess called.');\n    // Оновлюємо стан користувача на основі даних з логіну\n    setUser({\n      name: userDataFromLogin.name\n    });\n    setIsAdmin(userDataFromLogin.is_admin || false);\n    // setHasDevice залишається false поки не завершиться checkDeviceStatus\n    setError(null); // Очищаємо помилки\n\n    // *** ЗАПУСКАЄМО ПЕРЕВІРКУ ПРИСТРОЮ ПІСЛЯ УСПІШНОГО ЛОГІНУ ***\n    // Оскільки setUser є асинхронним, передаємо актуальні дані user в checkDeviceStatus\n    // або покладаємося на те, що useCallback має доступ до актуального user зі scope.\n    // Передача аргумента currentUser в checkDeviceStatus є безпечнішою.\n    checkDeviceStatus({\n      name: userDataFromLogin.name\n    }); // Передаємо актуальний user об'єкт\n\n    // localStorage вже збережено в LoginPage.\n  }, [checkDeviceStatus]); // Залежність від checkDeviceStatus\n\n  // Значення контексту, що передається\n  const contextValue = {\n    user,\n    // null або { name: string }\n    isAdmin,\n    // boolean\n    hasDevice,\n    // boolean (статус пристрою)\n    loadingInitial,\n    // boolean (чи йде початкове завантаження контексту)\n    loadingDevice,\n    // boolean (чи йде перевірка пристрою)\n    error,\n    // any\n    logoutUser,\n    // Функція для виходу\n    handleLoginSuccess,\n    // Функція для LoginPage при успішному логіні\n    checkDeviceStatus // Може знадобитись деінде для оновлення статусу пристрою\n  };\n  return /*#__PURE__*/_jsxDEV(UserContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 257,\n    columnNumber: 9\n  }, this);\n};\n_s(UserProvider, \"aO8Sk8xOU3eglm10JbhPmngQQ+4=\");\n_c = UserProvider;\nvar _c;\n$RefreshReg$(_c, \"UserProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useCallback","useRef","api","setUnauthorizedCallback","jsxDEV","_jsxDEV","UserContext","UserProvider","children","_s","user","setUser","storedUserId","localStorage","getItem","storedUserName","storedIsAdmin","storedProfilePictureUrl","console","log","id","name","is_admin","profile_picture_url","e","error","removeItem","isAdmin","setIsAdmin","userId","setUserId","hasDevice","setHasDevice","loadingDevice","setLoadingDevice","loadingInitial","setLoadingInitial","setError","isInitialCheckDone","checkDeviceStatus","currentUser","devicesRes","get","userHasDevice","data","length","err","_err$response","response","status","current","initialUserFromState","verifyAuthAndFetchUserData","res","withCredentials","fetchedUser","setItem","logoutUser","_error$response","handleLoginSuccess","userDataFromLogin","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/Program Files/WebstormProjects/soil_scout/web/src/contexts/UserContext.js"],"sourcesContent":["// contexts/UserContext.js\r\nimport React, { createContext, useState, useEffect, useCallback, useRef } from 'react'; // Додано useRef\r\n// Імпортуємо лише setUnauthorizedCallback\r\nimport api, { setUnauthorizedCallback } from '../utils/api'; // ВИДАЛЕНО: setIsLoggingOut\r\n\r\nexport const UserContext = createContext();\r\n\r\nexport const UserProvider = ({ children }) => {\r\n    // --- ОНОВЛЕНО: Початковий стан: ініціалізуємо з УСІХ даних localStorage, включаючи profile_picture_url, id, isAdmin ---\r\n    const [user, setUser] = useState(() => {\r\n        try { // Додано try/catch на випадок помилок парсингу localStorage\r\n            const storedUserId = localStorage.getItem('userId');\r\n            const storedUserName = localStorage.getItem('userName');\r\n            const storedIsAdmin = localStorage.getItem('isAdmin') === 'true';\r\n            const storedProfilePictureUrl = localStorage.getItem('userProfilePictureUrl'); // <-- Читаємо URL фото\r\n\r\n            // Повертаємо повний об'єкт, якщо є мінімальні дані\r\n            if (storedUserId && storedUserName !== null) { // Перевіряємо userName на null явно\r\n                console.log('Context: Initializing user from localStorage:', { storedUserId, storedUserName, storedIsAdmin, storedProfilePictureUrl });\r\n                return {\r\n                    id: storedUserId,\r\n                    name: storedUserName,\r\n                    is_admin: storedIsAdmin,\r\n                    profile_picture_url: storedProfilePictureUrl || null // Включаємо URL\r\n                    // TODO: Можливо, додати інші поля, які можуть зберігатись у LS при логіні/верифікації\r\n                };\r\n            }\r\n        } catch (e) {\r\n            console.error(\"Context: Error reading user data from localStorage\", e);\r\n            // Очистити localStorage, якщо сталося помилка\r\n            localStorage.removeItem('userId');\r\n            localStorage.removeItem('userName');\r\n            localStorage.removeItem('isAdmin');\r\n            localStorage.removeItem('userProfilePictureUrl');\r\n        }\r\n        return null; // Якщо даних у localStorage немає або помилка\r\n    });\r\n\r\n    // isAdmin та userId тепер ПОВИННІ братися з об'єкта user, або оновлюватися разом з ним.\r\n    // Краще брати їх з user, але якщо вони використовуються окремо, оновлюйте їх в setUser колбеках.\r\n    // Залишаємо їх окремо, але будемо синхронізувати.\r\n    const [isAdmin, setIsAdmin] = useState(() => localStorage.getItem('isAdmin') === 'true');\r\n    const [userId, setUserId] = useState(() => localStorage.getItem('userId'));\r\n\r\n    const [hasDevice, setHasDevice] = useState(false);\r\n    const [loadingDevice, setLoadingDevice] = useState(false);\r\n    const [loadingInitial, setLoadingInitial] = useState(true);\r\n    const [error, setError] = useState(null);\r\n\r\n    const isInitialCheckDone = useRef(false);\r\n\r\n    // --- Функція перевірки наявності пристрою ---\r\n    // Ця функція не має залежати від loadingDevice для свого useCallback,\r\n    // оскільки вона сама керує цим станом. Вона залежить від `user`.\r\n    const checkDeviceStatus = useCallback(async (currentUser) => {\r\n        // Робимо перевірку лише якщо користувач виглядає залогіненим (присутній user об'єкт)\r\n        // і ми ще не перевіряємо його пристрій\r\n        // Використовуємо аргумент currentUser, який передається (або беремо поточний user зі scope)\r\n        if (!currentUser) {\r\n            console.log('Context: checkDeviceStatus skipped - user is null.');\r\n            setHasDevice(false); // Якщо user = null, пристрою точно немає\r\n            // setLoadingDevice(false); // Переконаємося, що loadingDevice також false\r\n            return; // Не виконуємо запит\r\n        }\r\n        // Перевіряємо loadingDevice тут, щоб уникнути повторних викликів, якщо вони якось накладаються\r\n        if (loadingDevice) {\r\n            console.log('Context: checkDeviceStatus skipped - already checking.');\r\n            return;\r\n        }\r\n\r\n\r\n        setLoadingDevice(true);\r\n        console.log('Context: Performing device status check...');\r\n        try {\r\n            const devicesRes = await api.get('/user-iot-devices');\r\n            const userHasDevice = devicesRes.data && devicesRes.data.length > 0;\r\n            setHasDevice(userHasDevice);\r\n            console.log(`Context: Device check successful. Has device: ${userHasDevice}.`);\r\n            // setError(null);\r\n\r\n        } catch (err) {\r\n            console.error('Context: Failed to fetch user devices:', err);\r\n            // Перехоплювач обробить 401 і викличе logoutUser.\r\n            // Для інших помилок, вважаємо, що пристрій недоступний у цей момент.\r\n            if (err.response?.status !== 401) {\r\n                setHasDevice(false); // Встановлюємо false при інших помилках\r\n                // setError(err); // Можна встановити помилку\r\n            }\r\n        } finally {\r\n            setLoadingDevice(false);\r\n        }\r\n    }, [user]); // Залежність тільки від user\r\n\r\n    // --- Початкова перевірка при монтуванні ---\r\n    // Використовуємо реф, щоб переконатися, що цей ефект виконується лише один раз\r\n    useEffect(() => {\r\n        if (isInitialCheckDone.current) {\r\n            console.log('Context: Initial check already done, skipping useEffect.');\r\n            return;\r\n        }\r\n\r\n        isInitialCheckDone.current = true;\r\n        console.log('Context: Starting initial check useEffect.');\r\n\r\n        // Стан user вже ініціалізовано з localStorage перед useEffect\r\n        const initialUserFromState = user;\r\n\r\n        const verifyAuthAndFetchUserData = async () => {\r\n            setLoadingInitial(true); // Ставимо loadingInitial в true перед запитом\r\n\r\n            try {\r\n                // Викликаємо ендпоінт для отримання даних поточного користувача.\r\n                // Переконайтесь, що /auth/me повертає ПОВНИЙ об'єкт користувача (id, name, is_admin, profile_picture_url).\r\n                const res = await api.get('/auth/me', { withCredentials: true });\r\n                const fetchedUser = res.data.user; // Припускаємо, що дані користувача вкладені у 'user'\r\n\r\n                if (fetchedUser && fetchedUser.id) { // Перевіряємо, що об'єкт користувача та його ID валідні\r\n                    console.log('UserContext: Backend auth verification successful, user data fetched:', fetchedUser);\r\n                    // !!! КОРЕКЦІЯ: ОНОВЛЮЄМО СТАН КОРИСТУВАЧА ПОВНИМ ОБ'ЄКТОМ З БЕКЕНДУ !!!\r\n                    setUser(fetchedUser); // Це оновить user (включаючи id, name, is_admin, profile_picture_url)\r\n\r\n                    // Синхронізуємо isAdmin та userId стани\r\n                    setIsAdmin(fetchedUser.is_admin || false);\r\n                    setUserId(fetchedUser.id);\r\n\r\n\r\n                    // ОНОВЛЮЄМО localStorage СВІЖИМИ ДАНИМИ\r\n                    localStorage.setItem('userId', fetchedUser.id);\r\n                    localStorage.setItem('userName', fetchedUser.name);\r\n                    localStorage.setItem('isAdmin', fetchedUser.is_admin ? 'true' : 'false');\r\n                    if (fetchedUser.profile_picture_url) {\r\n                        localStorage.setItem('userProfilePictureUrl', fetchedUser.profile_picture_url);\r\n                        console.log('UserContext: Fresh profile picture URL saved to localStorage:', fetchedUser.profile_picture_url);\r\n                    } else {\r\n                        localStorage.removeItem('userProfilePictureUrl');\r\n                        console.log('UserContext: No fresh profile picture URL received, removed from localStorage.');\r\n                    }\r\n\r\n                    // Запускаємо перевірку статусу пристрою з отриманими даними користувача\r\n                    checkDeviceStatus(fetchedUser);\r\n                } else {\r\n                    console.log('UserContext: Backend auth verification failed (no user data), logging out locally.');\r\n                    // Якщо бекенд не повернув користувача або повернув невалідний об'єкт,\r\n                    // виконуємо локальний вихід.\r\n                    logoutUser();\r\n                }\r\n            } catch (error) {\r\n                console.error('UserContext: Auth verification API error:', error);\r\n                // Перехоплювач обробить 401. Для інших помилок:\r\n                if (error.response?.status !== 401) {\r\n                    console.log('UserContext: Verification failed due to non-401 error, performing local logout.');\r\n                    logoutUser(); // Локальний вихід при інших помилках запиту\r\n                }\r\n                // Якщо помилка 401, перехоплювач викличе logoutUser\r\n            } finally {\r\n                setLoadingInitial(false); // Початкове завантаження завершено після спроби верифікації\r\n                console.log('Context: Initial auth verification process finished.');\r\n            }\r\n        };\r\n\r\n        // Запускаємо процес верифікації, тільки якщо є якісь ознаки логіну в localStorage\r\n        // (тобто, якщо початковий стан user НЕ null)\r\n        if (initialUserFromState) {\r\n            console.log('UserContext: Initial user data found in localStorage, starting verification.');\r\n            verifyAuthAndFetchUserData();\r\n        } else {\r\n            // Немає початкових даних користувача в localStorage, верифікація не потрібна.\r\n            // Початкове завантаження завершено негайно.\r\n            console.log('Context: No initial user data, skipping verification.');\r\n            setLoadingInitial(false);\r\n            setHasDevice(false); // Переконаємося, що статус пристрою false\r\n        }\r\n\r\n\r\n    }, [checkDeviceStatus, logoutUser]); // Залежності ефекту\r\n\r\n\r\n    // --- Логіка Виходу ---\r\n    const logoutUser = useCallback(async () => {\r\n        console.log('Context: logoutUser called.');\r\n\r\n        // Опціонально: викликаємо endpoint для виходу на бекенді\r\n        // !!! ВАЖЛИВО: цей endpoint НЕ ПОВИНЕН повертати 401, який знову спрацює в перехоплювачі,\r\n        // коли сесія вже недійсна. Повинен повертати 200 або інший статус.\r\n        try {\r\n            console.log('Context: Attempting backend /auth/logout call (optional)...');\r\n            // await api.post('/auth/logout'); // Розкоментуйте, якщо маєте такий endpoint\r\n            console.log('Context: Backend logout call finished (or skipped).');\r\n        } catch (err) {\r\n            console.error('Context: Failed to call backend logout API:', err);\r\n        } finally {\r\n            // --- Очищення стану та localStorage ---\r\n            console.log('Context: Performing local logout cleanup.');\r\n            setUser(null);\r\n            setIsAdmin(false);\r\n            setHasDevice(false); // При виході пристрою точно немає\r\n            setLoadingDevice(false); // При виході скасовуємо будь-яке завантаження пристрою\r\n            localStorage.removeItem('userName');\r\n            localStorage.removeItem('isAdmin');\r\n            localStorage.removeItem('userProfilePictureUrl'); // <-- Видаляємо URL фото з localStorage\r\n\r\n            // localStorage.removeItem('token'); // Розкоментуйте, якщо зберігаєте токен у localStorage\r\n\r\n            // *** Немає isLoggingOut прапорця для скидання ***\r\n\r\n            // *** ВАЖЛИВО: Перенаправлення на /login сторінку відбувається в App (або роутері),\r\n            // який спостерігає за зміною стану 'user' на null. ***\r\n        }\r\n    }, []);\r\n\r\n    // --- Зв'язуємо logoutUser з перехоплювачем API ---\r\n    useEffect(() => {\r\n        console.log('Context: Setting API unauthorized callback.');\r\n        setUnauthorizedCallback(logoutUser);\r\n\r\n        return () => {\r\n            console.log('Context: Clearing API unauthorized callback.');\r\n            setUnauthorizedCallback(null);\r\n        };\r\n    }, [logoutUser]);\r\n\r\n\r\n    // --- Функція для обробки успіху логіну (викликається з LoginPage) ---\r\n    const handleLoginSuccess = useCallback((userDataFromLogin) => {\r\n        console.log('Context: handleLoginSuccess called.');\r\n        // Оновлюємо стан користувача на основі даних з логіну\r\n        setUser({ name: userDataFromLogin.name });\r\n        setIsAdmin(userDataFromLogin.is_admin || false);\r\n        // setHasDevice залишається false поки не завершиться checkDeviceStatus\r\n        setError(null); // Очищаємо помилки\r\n\r\n        // *** ЗАПУСКАЄМО ПЕРЕВІРКУ ПРИСТРОЮ ПІСЛЯ УСПІШНОГО ЛОГІНУ ***\r\n        // Оскільки setUser є асинхронним, передаємо актуальні дані user в checkDeviceStatus\r\n        // або покладаємося на те, що useCallback має доступ до актуального user зі scope.\r\n        // Передача аргумента currentUser в checkDeviceStatus є безпечнішою.\r\n        checkDeviceStatus({ name: userDataFromLogin.name }); // Передаємо актуальний user об'єкт\r\n\r\n        // localStorage вже збережено в LoginPage.\r\n\r\n    }, [checkDeviceStatus]); // Залежність від checkDeviceStatus\r\n\r\n\r\n    // Значення контексту, що передається\r\n    const contextValue = {\r\n        user, // null або { name: string }\r\n        isAdmin, // boolean\r\n        hasDevice, // boolean (статус пристрою)\r\n        loadingInitial, // boolean (чи йде початкове завантаження контексту)\r\n        loadingDevice, // boolean (чи йде перевірка пристрою)\r\n        error, // any\r\n        logoutUser, // Функція для виходу\r\n        handleLoginSuccess, // Функція для LoginPage при успішному логіні\r\n        checkDeviceStatus, // Може знадобитись деінде для оновлення статусу пристрою\r\n    };\r\n\r\n    return (\r\n        <UserContext.Provider value={contextValue}>\r\n            {children}\r\n        </UserContext.Provider>\r\n    );\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}