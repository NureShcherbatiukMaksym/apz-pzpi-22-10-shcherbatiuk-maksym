{"ast":null,"code":"var _jsxFileName = \"D:\\\\Program Files\\\\WebstormProjects\\\\soil_scout\\\\web\\\\src\\\\contexts\\\\UserContext.js\",\n  _s = $RefreshSig$();\n// contexts/UserContext.js\nimport React, { createContext, useState, useEffect, useCallback, useRef } from 'react';\nimport api, { setUnauthorizedCallback } from '../utils/api';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const UserContext = /*#__PURE__*/createContext();\nexport const UserProvider = ({\n  children\n}) => {\n  _s();\n  // --- ОНОВЛЕНО: Початковий стан: ініціалізуємо користувача з УСІХ даних localStorage, включаючи URL фото ---\n  const [user, setUser] = useState(() => {\n    const storedUserId = localStorage.getItem('userId');\n    const storedUserName = localStorage.getItem('userName');\n    const storedIsAdmin = localStorage.getItem('isAdmin') === 'true'; // Парсимо isAdmin як булеве\n    const storedProfilePictureUrl = localStorage.getItem('userProfilePictureUrl'); // <-- Отримуємо URL фото з localStorage\n\n    // Конструюємо об'єкт користувача, якщо є мінімальні дані (ID та Ім'я)\n    if (storedUserId && storedUserName) {\n      return {\n        id: storedUserId,\n        name: storedUserName,\n        is_admin: storedIsAdmin,\n        // Включаємо isAdmin\n        profile_picture_url: storedProfilePictureUrl || null // <-- Включаємо URL фото (або null, якщо немає)\n      };\n    }\n    return null; // Якщо немає ID або Ім'я, користувач не залогінений за localStorage\n  });\n\n  // isAdmin та userId можна отримати з об'єкта user, але залишаємо їх окремо, як було\n  // Ініціалізуємо їх з localStorage також\n  const [isAdmin, setIsAdmin] = useState(() => localStorage.getItem('isAdmin') === 'true');\n  const [userId, setUserId] = useState(() => localStorage.getItem('userId'));\n  const [hasDevice, setHasDevice] = useState(false);\n  const [loadingDevice, setLoadingDevice] = useState(false);\n  const [loadingInitial, setLoadingInitial] = useState(true);\n  const [error, setError] = useState(null);\n  const isInitialCheckDone = useRef(false);\n\n  // --- Функція перевірки наявності пристрою (залежить від user.id) ---\n  // Використовуємо аргумент currentUser для доступу до актуального user об'єкта з id\n  const checkDeviceStatus = useCallback(async currentUser => {\n    // Використовуємо переданий аргумент або поточний стан user\n    const userToCheck = currentUser || user;\n\n    // Перевіряємо наявність об'єкта користувача та його ID\n    if (!userToCheck || !userToCheck.id) {\n      console.log('Context: checkDeviceStatus skipped - user or user ID is null.');\n      setHasDevice(false);\n      // setLoadingDevice(false); // Можна додати скидання стану завантаження тут\n      return;\n    }\n\n    // Перевіряємо loadingDevice, щоб уникнути повторних викликів\n    if (loadingDevice) {\n      console.log('Context: checkDeviceStatus skipped - already checking.');\n      return;\n    }\n    setLoadingDevice(true);\n    console.log('Context: Performing device status check for user ID:', userToCheck.id); // Використовуємо userToCheck.id\n    try {\n      const devicesRes = await api.get('/user-iot-devices');\n      const userHasDevice = devicesRes.data && devicesRes.data.length > 0;\n      setHasDevice(userHasDevice);\n      console.log(`Context: Device check successful. Has device: ${userHasDevice}.`);\n    } catch (err) {\n      var _err$response;\n      console.error('Context: Failed to fetch user devices:', err);\n      if (((_err$response = err.response) === null || _err$response === void 0 ? void 0 : _err$response.status) !== 401) {\n        // 401 обробляється перехоплювачем\n        setHasDevice(false);\n        // setError(err); // Можна встановити помилку\n      }\n    } finally {\n      setLoadingDevice(false);\n    }\n  }, [user, loadingDevice]); // Додано user та loadingDevice до залежностей\n\n  // --- Початкова перевірка при монтуванні (включаючи верифікацію сесії та отримання свіжих даних користувача) ---\n  useEffect(() => {\n    if (isInitialCheckDone.current) {\n      console.log('Context: Initial check already done, skipping useEffect.');\n      return;\n    }\n    isInitialCheckDone.current = true;\n    console.log('Context: Starting initial check useEffect.');\n\n    // Стан user вже ініціалізовано з localStorage перед useEffect\n    const initialUserFromState = user;\n\n    // Функція для верифікації сесії та отримання свіжих даних користувача з бекенду\n    const verifyAuthAndFetchUserData = async () => {\n      try {\n        // Викликаємо ендпоінт на бекенді для отримання даних поточного користувача\n        // Припускаємо, що цей ендпоінт (наприклад, /auth/me) повертає ПОВНИЙ об'єкт користувача, ВКЛЮЧАЮЧИ profile_picture_url\n        const res = await api.get('/auth/me', {\n          withCredentials: true\n        });\n        const fetchedUser = res.data.user; // Припускаємо, що дані користувача вкладені у 'user'\n\n        if (fetchedUser) {\n          console.log('UserContext: Backend auth verification successful, user data fetched:', fetchedUser);\n          // !!! ОНОВЛЮЄМО СТАН КОРИСТУВАЧА ПОВНИМ ОБ'ЄКТОМ З БЕКЕНДУ !!!\n          setUser(fetchedUser); // Це оновить id, name, is_admin, profile_picture_url\n\n          // ОНОВЛЮЄМО localStorage СВІЖИМИ ДАНИМИ\n          localStorage.setItem('userId', fetchedUser.id);\n          localStorage.setItem('userName', fetchedUser.name);\n          localStorage.setItem('isAdmin', fetchedUser.is_admin ? 'true' : 'false');\n          // !!! ЗБЕРІГАЄМО СВІЖИЙ URL ФОТО В localStorage !!!\n          if (fetchedUser.profile_picture_url) {\n            localStorage.setItem('userProfilePictureUrl', fetchedUser.profile_picture_url);\n            console.log('UserContext: Fresh profile picture URL saved to localStorage:', fetchedUser.profile_picture_url);\n          } else {\n            localStorage.removeItem('userProfilePictureUrl');\n            console.log('UserContext: No fresh profile picture URL received, removed from localStorage.');\n          }\n\n          // Оновлюємо isAdmin та userId стани на основі свіжих даних\n          setIsAdmin(fetchedUser.is_admin);\n          setUserId(fetchedUser.id);\n\n          // Тепер, коли стан user оновлено, можемо безпечно запустити checkDeviceStatus,\n          // або покладатися на те, що зміна стану user викличе ефект, який запускає checkDeviceStatus.\n          checkDeviceStatus(fetchedUser); // Передаємо свіжий об'єкт fetchedUser\n        } else {\n          console.log('UserContext: Backend auth verification failed, logging out locally.');\n          // Якщо бекенд не повернув користувача, незважаючи на, здавалося б, дійсну сесію,\n          // виконуємо локальний вихід.\n          logoutUser();\n        }\n      } catch (error) {\n        console.error('UserContext: Auth verification API error:', error);\n        // Перехоплювач обробить 401 помилку і викличе logoutUser.\n        // Для інших помилок (наприклад, мережевих) також можемо виконати локальний вихід.\n        // logoutUser(); // Опціонально: виконувати локальний вихід при будь-якій помилці верифікації\n      } finally {\n        // Початкове завантаження завершено після спроби верифікації\n        setLoadingInitial(false);\n        console.log('Context: Initial auth verification process finished.');\n      }\n    };\n\n    // Запускаємо процес верифікації, якщо з localStorage були якісь дані користувача\n    if (initialUserFromState) {\n      console.log('UserContext: Initial user data found in localStorage, starting verification.');\n      verifyAuthAndFetchUserData();\n    } else {\n      // Немає початкових даних користувача в localStorage, верифікація не потрібна.\n      // Початкове завантаження завершено негайно.\n      console.log('UserContext: No initial user data, skipping verification.');\n      setLoadingInitial(false);\n      setHasDevice(false); // Переконаємося, що статус пристрою false\n    }\n  }, [checkDeviceStatus, logoutUser]); // Додано checkDeviceStatus та logoutUser до залежностей\n\n  // --- Логіка Виходу ---\n  const logoutUser = useCallback(async () => {\n    console.log('Context: logoutUser called.');\n    try {\n      console.log('Context: Attempting backend /auth/logout call (optional)...');\n      await api.post('/auth/logout'); // Викликаємо ендпоінт виходу на бекенді\n      console.log('Context: Backend logout call finished.');\n    } catch (err) {\n      console.error('Context: Failed to call backend logout API:', err);\n      // Логуємо помилку, але продовжуємо локальне очищення незалежно від успіху API виходу\n    } finally {\n      // --- Очищення стану контексту та localStorage ---\n      console.log('Context: Performing local logout cleanup.');\n      // !!! Скидаємо УСІ відповідні змінні стану !!!\n      setUser(null); // Встановлюємо об'єкт користувача в null\n      setIsAdmin(false); // Скидаємо isAdmin\n      setUserId(null); // Скидаємо userId\n      setHasDevice(false); // Скидаємо статус пристрою\n      setLoadingDevice(false); // Скидаємо стан завантаження пристрою\n      setError(null); // Очищаємо помилки\n\n      // !!! Видаляємо УСІ відповідні елементи з localStorage !!!\n      localStorage.removeItem('userId');\n      localStorage.removeItem('userName');\n      localStorage.removeItem('isAdmin');\n      localStorage.removeItem('userProfilePictureUrl'); // <-- Видаляємо URL фото з localStorage\n\n      console.log('Context: Local logout cleanup finished.');\n    }\n  }, []); // Залежності не потрібні, якщо внутрішні функції не змінюються\n\n  // --- Зв'язуємо logoutUser з перехоплювачем API ---\n  useEffect(() => {\n    console.log('Context: Setting API unauthorized callback.');\n    setUnauthorizedCallback(logoutUser);\n    return () => {\n      console.log('Context: Clearing API unauthorized callback.');\n      setUnauthorizedCallback(null);\n    };\n  }, [logoutUser]); // Залежність від logoutUser\n\n  // --- Функція для обробки успіху логіну (викликається з LoginPage) ---\n  const handleLoginSuccess = useCallback(userDataFromLogin => {\n    console.log('Context: handleLoginSuccess called with userData:', userDataFromLogin);\n    // !!! ОНОВЛЮЄМО СТАН КОРИСТУВАЧА ПОВНИМ ОБ'ЄКТОМ, ОТРИМАНИМ З LoginPage !!!\n    // Цей об'єкт userDataFromLogin має містити id, name, is_admin, ТА profile_picture_url\n    setUser(userDataFromLogin);\n\n    // Оновлюємо isAdmin та userId стани на основі нового об'єкта user\n    setIsAdmin(userDataFromLogin.is_admin || false);\n    setUserId(userDataFromLogin.id);\n    setError(null); // Очищаємо помилки\n\n    // Збереження даних в localStorage тепер повністю відбувається в LoginPage перед викликом handleLoginSuccess.\n    // Логіка localStorage тут при handleLoginSuccess більше не потрібна.\n\n    // *** ЗАПУСКАЄМО ПЕРЕВІРКУ СТАТУСУ ПРИСТРОЮ ПІСЛЯ УСПІШНОГО ЛОГІНУ ***\n    // Передаємо checkDeviceStatus актуальний об'єкт user для перевірки за ID\n    checkDeviceStatus(userDataFromLogin); // Передаємо user з login data\n  }, [checkDeviceStatus]); // Залежність від checkDeviceStatus\n\n  // Значення контексту, що передається\n  const contextValue = {\n    user,\n    // !!! Надаємо ПОВНИЙ об'єкт користувача !!!\n    isAdmin,\n    // boolean\n    userId,\n    // string або null\n    hasDevice,\n    // boolean\n    loadingInitial,\n    // boolean\n    loadingDevice,\n    // boolean\n    error,\n    // any\n    logoutUser,\n    // Функція для виходу\n    handleLoginSuccess // Функція для LoginPage при успішному логіні\n    // checkDeviceStatus, // Немає потреби надавати її зовнішнім компонентам, якщо вона викликається внутрішньо\n  };\n  return /*#__PURE__*/_jsxDEV(UserContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 246,\n    columnNumber: 9\n  }, this);\n};\n_s(UserProvider, \"VzJDwL/WMqFPNHNTAtVkO5KzstA=\");\n_c = UserProvider;\nvar _c;\n$RefreshReg$(_c, \"UserProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useCallback","useRef","api","setUnauthorizedCallback","jsxDEV","_jsxDEV","UserContext","UserProvider","children","_s","user","setUser","storedUserId","localStorage","getItem","storedUserName","storedIsAdmin","storedProfilePictureUrl","id","name","is_admin","profile_picture_url","isAdmin","setIsAdmin","userId","setUserId","hasDevice","setHasDevice","loadingDevice","setLoadingDevice","loadingInitial","setLoadingInitial","error","setError","isInitialCheckDone","checkDeviceStatus","currentUser","userToCheck","console","log","devicesRes","get","userHasDevice","data","length","err","_err$response","response","status","current","initialUserFromState","verifyAuthAndFetchUserData","res","withCredentials","fetchedUser","setItem","removeItem","logoutUser","post","handleLoginSuccess","userDataFromLogin","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/Program Files/WebstormProjects/soil_scout/web/src/contexts/UserContext.js"],"sourcesContent":["// contexts/UserContext.js\r\nimport React, { createContext, useState, useEffect, useCallback, useRef } from 'react';\r\nimport api, { setUnauthorizedCallback } from '../utils/api';\r\n\r\nexport const UserContext = createContext();\r\n\r\nexport const UserProvider = ({ children }) => {\r\n    // --- ОНОВЛЕНО: Початковий стан: ініціалізуємо користувача з УСІХ даних localStorage, включаючи URL фото ---\r\n    const [user, setUser] = useState(() => {\r\n        const storedUserId = localStorage.getItem('userId');\r\n        const storedUserName = localStorage.getItem('userName');\r\n        const storedIsAdmin = localStorage.getItem('isAdmin') === 'true'; // Парсимо isAdmin як булеве\r\n        const storedProfilePictureUrl = localStorage.getItem('userProfilePictureUrl'); // <-- Отримуємо URL фото з localStorage\r\n\r\n        // Конструюємо об'єкт користувача, якщо є мінімальні дані (ID та Ім'я)\r\n        if (storedUserId && storedUserName) {\r\n            return {\r\n                id: storedUserId,\r\n                name: storedUserName,\r\n                is_admin: storedIsAdmin, // Включаємо isAdmin\r\n                profile_picture_url: storedProfilePictureUrl || null // <-- Включаємо URL фото (або null, якщо немає)\r\n            };\r\n        }\r\n        return null; // Якщо немає ID або Ім'я, користувач не залогінений за localStorage\r\n    });\r\n\r\n    // isAdmin та userId можна отримати з об'єкта user, але залишаємо їх окремо, як було\r\n    // Ініціалізуємо їх з localStorage також\r\n    const [isAdmin, setIsAdmin] = useState(() => localStorage.getItem('isAdmin') === 'true');\r\n    const [userId, setUserId] = useState(() => localStorage.getItem('userId'));\r\n\r\n\r\n    const [hasDevice, setHasDevice] = useState(false);\r\n    const [loadingDevice, setLoadingDevice] = useState(false);\r\n    const [loadingInitial, setLoadingInitial] = useState(true);\r\n    const [error, setError] = useState(null);\r\n\r\n    const isInitialCheckDone = useRef(false);\r\n\r\n\r\n    // --- Функція перевірки наявності пристрою (залежить від user.id) ---\r\n    // Використовуємо аргумент currentUser для доступу до актуального user об'єкта з id\r\n    const checkDeviceStatus = useCallback(async (currentUser) => {\r\n        // Використовуємо переданий аргумент або поточний стан user\r\n        const userToCheck = currentUser || user;\r\n\r\n        // Перевіряємо наявність об'єкта користувача та його ID\r\n        if (!userToCheck || !userToCheck.id) {\r\n            console.log('Context: checkDeviceStatus skipped - user or user ID is null.');\r\n            setHasDevice(false);\r\n            // setLoadingDevice(false); // Можна додати скидання стану завантаження тут\r\n            return;\r\n        }\r\n\r\n        // Перевіряємо loadingDevice, щоб уникнути повторних викликів\r\n        if (loadingDevice) {\r\n            console.log('Context: checkDeviceStatus skipped - already checking.');\r\n            return;\r\n        }\r\n\r\n\r\n        setLoadingDevice(true);\r\n        console.log('Context: Performing device status check for user ID:', userToCheck.id); // Використовуємо userToCheck.id\r\n        try {\r\n            const devicesRes = await api.get('/user-iot-devices');\r\n            const userHasDevice = devicesRes.data && devicesRes.data.length > 0;\r\n            setHasDevice(userHasDevice);\r\n            console.log(`Context: Device check successful. Has device: ${userHasDevice}.`);\r\n\r\n        } catch (err) {\r\n            console.error('Context: Failed to fetch user devices:', err);\r\n            if (err.response?.status !== 401) { // 401 обробляється перехоплювачем\r\n                setHasDevice(false);\r\n                // setError(err); // Можна встановити помилку\r\n            }\r\n        } finally {\r\n            setLoadingDevice(false);\r\n        }\r\n    }, [user, loadingDevice]); // Додано user та loadingDevice до залежностей\r\n\r\n\r\n    // --- Початкова перевірка при монтуванні (включаючи верифікацію сесії та отримання свіжих даних користувача) ---\r\n    useEffect(() => {\r\n        if (isInitialCheckDone.current) {\r\n            console.log('Context: Initial check already done, skipping useEffect.');\r\n            return;\r\n        }\r\n\r\n        isInitialCheckDone.current = true;\r\n        console.log('Context: Starting initial check useEffect.');\r\n\r\n        // Стан user вже ініціалізовано з localStorage перед useEffect\r\n        const initialUserFromState = user;\r\n\r\n        // Функція для верифікації сесії та отримання свіжих даних користувача з бекенду\r\n        const verifyAuthAndFetchUserData = async () => {\r\n            try {\r\n                // Викликаємо ендпоінт на бекенді для отримання даних поточного користувача\r\n                // Припускаємо, що цей ендпоінт (наприклад, /auth/me) повертає ПОВНИЙ об'єкт користувача, ВКЛЮЧАЮЧИ profile_picture_url\r\n                const res = await api.get('/auth/me', { withCredentials: true });\r\n                const fetchedUser = res.data.user; // Припускаємо, що дані користувача вкладені у 'user'\r\n\r\n                if (fetchedUser) {\r\n                    console.log('UserContext: Backend auth verification successful, user data fetched:', fetchedUser);\r\n                    // !!! ОНОВЛЮЄМО СТАН КОРИСТУВАЧА ПОВНИМ ОБ'ЄКТОМ З БЕКЕНДУ !!!\r\n                    setUser(fetchedUser); // Це оновить id, name, is_admin, profile_picture_url\r\n\r\n                    // ОНОВЛЮЄМО localStorage СВІЖИМИ ДАНИМИ\r\n                    localStorage.setItem('userId', fetchedUser.id);\r\n                    localStorage.setItem('userName', fetchedUser.name);\r\n                    localStorage.setItem('isAdmin', fetchedUser.is_admin ? 'true' : 'false');\r\n                    // !!! ЗБЕРІГАЄМО СВІЖИЙ URL ФОТО В localStorage !!!\r\n                    if (fetchedUser.profile_picture_url) {\r\n                        localStorage.setItem('userProfilePictureUrl', fetchedUser.profile_picture_url);\r\n                        console.log('UserContext: Fresh profile picture URL saved to localStorage:', fetchedUser.profile_picture_url);\r\n                    } else {\r\n                        localStorage.removeItem('userProfilePictureUrl');\r\n                        console.log('UserContext: No fresh profile picture URL received, removed from localStorage.');\r\n                    }\r\n\r\n                    // Оновлюємо isAdmin та userId стани на основі свіжих даних\r\n                    setIsAdmin(fetchedUser.is_admin);\r\n                    setUserId(fetchedUser.id);\r\n\r\n\r\n                    // Тепер, коли стан user оновлено, можемо безпечно запустити checkDeviceStatus,\r\n                    // або покладатися на те, що зміна стану user викличе ефект, який запускає checkDeviceStatus.\r\n                    checkDeviceStatus(fetchedUser); // Передаємо свіжий об'єкт fetchedUser\r\n                } else {\r\n                    console.log('UserContext: Backend auth verification failed, logging out locally.');\r\n                    // Якщо бекенд не повернув користувача, незважаючи на, здавалося б, дійсну сесію,\r\n                    // виконуємо локальний вихід.\r\n                    logoutUser();\r\n                }\r\n            } catch (error) {\r\n                console.error('UserContext: Auth verification API error:', error);\r\n                // Перехоплювач обробить 401 помилку і викличе logoutUser.\r\n                // Для інших помилок (наприклад, мережевих) також можемо виконати локальний вихід.\r\n                // logoutUser(); // Опціонально: виконувати локальний вихід при будь-якій помилці верифікації\r\n            } finally {\r\n                // Початкове завантаження завершено після спроби верифікації\r\n                setLoadingInitial(false);\r\n                console.log('Context: Initial auth verification process finished.');\r\n            }\r\n        };\r\n\r\n        // Запускаємо процес верифікації, якщо з localStorage були якісь дані користувача\r\n        if (initialUserFromState) {\r\n            console.log('UserContext: Initial user data found in localStorage, starting verification.');\r\n            verifyAuthAndFetchUserData();\r\n        } else {\r\n            // Немає початкових даних користувача в localStorage, верифікація не потрібна.\r\n            // Початкове завантаження завершено негайно.\r\n            console.log('UserContext: No initial user data, skipping verification.');\r\n            setLoadingInitial(false);\r\n            setHasDevice(false); // Переконаємося, що статус пристрою false\r\n        }\r\n\r\n\r\n    }, [checkDeviceStatus, logoutUser]); // Додано checkDeviceStatus та logoutUser до залежностей\r\n\r\n\r\n    // --- Логіка Виходу ---\r\n    const logoutUser = useCallback(async () => {\r\n        console.log('Context: logoutUser called.');\r\n\r\n        try {\r\n            console.log('Context: Attempting backend /auth/logout call (optional)...');\r\n            await api.post('/auth/logout'); // Викликаємо ендпоінт виходу на бекенді\r\n            console.log('Context: Backend logout call finished.');\r\n        } catch (err) {\r\n            console.error('Context: Failed to call backend logout API:', err);\r\n            // Логуємо помилку, але продовжуємо локальне очищення незалежно від успіху API виходу\r\n        } finally {\r\n            // --- Очищення стану контексту та localStorage ---\r\n            console.log('Context: Performing local logout cleanup.');\r\n            // !!! Скидаємо УСІ відповідні змінні стану !!!\r\n            setUser(null); // Встановлюємо об'єкт користувача в null\r\n            setIsAdmin(false); // Скидаємо isAdmin\r\n            setUserId(null); // Скидаємо userId\r\n            setHasDevice(false); // Скидаємо статус пристрою\r\n            setLoadingDevice(false); // Скидаємо стан завантаження пристрою\r\n            setError(null); // Очищаємо помилки\r\n\r\n            // !!! Видаляємо УСІ відповідні елементи з localStorage !!!\r\n            localStorage.removeItem('userId');\r\n            localStorage.removeItem('userName');\r\n            localStorage.removeItem('isAdmin');\r\n            localStorage.removeItem('userProfilePictureUrl'); // <-- Видаляємо URL фото з localStorage\r\n\r\n            console.log('Context: Local logout cleanup finished.');\r\n        }\r\n    }, []); // Залежності не потрібні, якщо внутрішні функції не змінюються\r\n\r\n\r\n    // --- Зв'язуємо logoutUser з перехоплювачем API ---\r\n    useEffect(() => {\r\n        console.log('Context: Setting API unauthorized callback.');\r\n        setUnauthorizedCallback(logoutUser);\r\n\r\n        return () => {\r\n            console.log('Context: Clearing API unauthorized callback.');\r\n            setUnauthorizedCallback(null);\r\n        };\r\n    }, [logoutUser]); // Залежність від logoutUser\r\n\r\n\r\n    // --- Функція для обробки успіху логіну (викликається з LoginPage) ---\r\n    const handleLoginSuccess = useCallback((userDataFromLogin) => {\r\n        console.log('Context: handleLoginSuccess called with userData:', userDataFromLogin);\r\n        // !!! ОНОВЛЮЄМО СТАН КОРИСТУВАЧА ПОВНИМ ОБ'ЄКТОМ, ОТРИМАНИМ З LoginPage !!!\r\n        // Цей об'єкт userDataFromLogin має містити id, name, is_admin, ТА profile_picture_url\r\n        setUser(userDataFromLogin);\r\n\r\n        // Оновлюємо isAdmin та userId стани на основі нового об'єкта user\r\n        setIsAdmin(userDataFromLogin.is_admin || false);\r\n        setUserId(userDataFromLogin.id);\r\n\r\n        setError(null); // Очищаємо помилки\r\n\r\n        // Збереження даних в localStorage тепер повністю відбувається в LoginPage перед викликом handleLoginSuccess.\r\n        // Логіка localStorage тут при handleLoginSuccess більше не потрібна.\r\n\r\n        // *** ЗАПУСКАЄМО ПЕРЕВІРКУ СТАТУСУ ПРИСТРОЮ ПІСЛЯ УСПІШНОГО ЛОГІНУ ***\r\n        // Передаємо checkDeviceStatus актуальний об'єкт user для перевірки за ID\r\n        checkDeviceStatus(userDataFromLogin); // Передаємо user з login data\r\n\r\n    }, [checkDeviceStatus]); // Залежність від checkDeviceStatus\r\n\r\n\r\n    // Значення контексту, що передається\r\n    const contextValue = {\r\n        user, // !!! Надаємо ПОВНИЙ об'єкт користувача !!!\r\n        isAdmin, // boolean\r\n        userId, // string або null\r\n        hasDevice, // boolean\r\n        loadingInitial, // boolean\r\n        loadingDevice, // boolean\r\n        error, // any\r\n        logoutUser, // Функція для виходу\r\n        handleLoginSuccess, // Функція для LoginPage при успішному логіні\r\n        // checkDeviceStatus, // Немає потреби надавати її зовнішнім компонентам, якщо вона викликається внутрішньо\r\n    };\r\n\r\n    return (\r\n        <UserContext.Provider value={contextValue}>\r\n            {children}\r\n        </UserContext.Provider>\r\n    );\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}