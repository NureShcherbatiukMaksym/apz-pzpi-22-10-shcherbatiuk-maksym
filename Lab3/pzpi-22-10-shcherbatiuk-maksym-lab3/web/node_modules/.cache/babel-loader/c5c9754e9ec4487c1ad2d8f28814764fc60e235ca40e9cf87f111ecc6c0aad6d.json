{"ast":null,"code":"var _jsxFileName = \"D:\\\\Program Files\\\\WebstormProjects\\\\soil_scout\\\\web\\\\src\\\\contexts\\\\UserContext.js\",\n  _s = $RefreshSig$();\n// src/contexts/UserContext.js\nimport React, { createContext, useState, useEffect, useCallback, useRef } from 'react';\n// Імпортуємо лише setUnauthorizedCallback\nimport api, { setUnauthorizedCallback } from '../utils/api'; // ВИДАЛЕНО: setIsLoggingOut\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const UserContext = /*#__PURE__*/createContext();\nexport const UserProvider = ({\n  children\n}) => {\n  _s();\n  // !!! Стан користувача буде зберігати ПОВНИЙ об'єкт користувача або null !!!\n  // Початковий стан - null. Дані будуть завантажені при початковій перевірці аутентифікації.\n  const [user, setUser] = useState(null);\n\n  // Ці стани можна отримати з об'єкта user, але зберігаємо їх окремо для зручності,\n  // якщо вони активно використовуються в різних компонентах.\n  const [isAdmin, setIsAdmin] = useState(false); // Буде встановлюватися з user.is_admin\n  // const [userId, setUserId] = useState(null); // userId можна отримати з user?.id\n\n  const [hasDevice, setHasDevice] = useState(false);\n  const [loadingDevice, setLoadingDevice] = useState(false);\n  const [loadingInitial, setLoadingInitial] = useState(true); // Старт з true\n  const [error, setError] = useState(null); // Загальний стан помилки\n\n  // Реф для відстеження, чи була виконана початкова перевірка аутентифікації\n  const isInitialAuthCheckDone = useRef(false); // Змінено назву для ясності\n\n  // --- Функція перевірки наявності пристрою ---\n  // Викликається після успішної аутентифікації або при початковій перевірці\n  const checkDeviceStatus = useCallback(async currentUser => {\n    // Робимо перевірку лише якщо користувач виглядає залогіненим (присутній user об'єкт)\n    // і ми ще не перевіряємо його пристрій\n    if (!currentUser) {\n      console.log('Context: checkDeviceStatus skipped - user is null.');\n      setHasDevice(false);\n      // setLoadingDevice(false); // Не скидаємо тут, скинемо у finally, якщо він був true\n      return; // Не виконуємо запит\n    }\n    // Перевіряємо loadingDevice тут, щоб уникнути повторних викликів\n    if (loadingDevice) {\n      console.log('Context: checkDeviceStatus skipped - already checking.');\n      return;\n    }\n    setLoadingDevice(true);\n    console.log('Context: Performing device status check...');\n    try {\n      const devicesRes = await api.get('/user-iot-devices'); // Ваш ендпоінт для перевірки пристроїв\n      const userHasDevice = devicesRes.data && devicesRes.data.length > 0;\n      setHasDevice(userHasDevice);\n      console.log(`Context: Device check successful. Has device: ${userHasDevice}.`);\n      // setError(null); // Можна очищати помилки, пов'язані з пристроєм\n    } catch (err) {\n      var _err$response;\n      console.error('Context: Failed to fetch user devices:', err);\n      // Перехоплювач обробить 401 і викличе logoutUser.\n      // Для інших помилок, вважаємо, що пристрій недоступний у цей момент.\n      if (((_err$response = err.response) === null || _err$response === void 0 ? void 0 : _err$response.status) !== 401) {\n        setHasDevice(false); // Встановлюємо false при інших помилках запиту пристрою\n        // setError(err); // Можна встановити помилку, пов'язану з пристроєм\n      }\n    } finally {\n      setLoadingDevice(false); // Завершуємо завантаження статусу пристрою\n    }\n  }, [loadingDevice]); // Залежність від loadingDevice\n\n  // --- Початкова перевірка аутентифікації при монтуванні ---\n  // Цей ефект перевіряє, чи користувач вже аутентифікований (наприклад, за cookie),\n  // і завантажує його повні дані з бекенду.\n  useEffect(() => {\n    // Використовуємо реф, щоб переконатися, що цей ефект спрацює лише один раз при першому монтуванні\n    if (isInitialAuthCheckDone.current) {\n      console.log('Context: Initial auth check already done, skipping useEffect.');\n      return;\n    }\n    isInitialAuthCheckDone.current = true; // Позначаємо, що перевірка почалася\n    console.log('Context: Starting initial auth check useEffect.');\n    const checkAuthStatus = async () => {\n      try {\n        // Викликаємо бекенд-ендпоінт для отримання даних поточного аутентифікованого користувача\n        // Цей ендпоінт /auth/me має повертати ПОВНИЙ об'єкт користувача, включаючи profile_picture_url\n        const res = await api.get('/auth/me', {\n          withCredentials: true\n        });\n        // Припускаємо, що дані користувача знаходяться у res.data.user\n        const fetchedUser = res.data.user;\n        if (fetchedUser) {\n          console.log('Context: Initial auth check successful. Fetched user data:', fetchedUser);\n          // !!! Встановлюємо ПОВНИЙ об'єкт користувача у стан контексту !!!\n          setUser(fetchedUser);\n          // Оновлюємо похідні стани з отриманих даних\n          setIsAdmin(fetchedUser.is_admin || false); // Переконаємося, що це boolean\n          // userId можна отримати з fetchedUser.id, якщо він потрібен окремо\n\n          // Зберігаємо URL фото в localStorage, якщо він прийшов\n          if (fetchedUser.profile_picture_url) {\n            localStorage.setItem('userProfilePictureUrl', fetchedUser.profile_picture_url);\n            console.log('Context: Profile picture URL saved to localStorage from /auth/me.');\n          } else {\n            localStorage.removeItem('userProfilePictureUrl'); // Видаляємо, якщо не прийшов\n            console.log('Context: No profile picture URL from /auth/me, removed from localStorage.');\n          }\n\n          // Запускаємо перевірку статусу пристрою для завантаженого користувача\n          checkDeviceStatus(fetchedUser); // Передаємо повний об'єкт користувача\n        } else {\n          console.log('Context: No active session found during initial /auth/me check.');\n          // Якщо користувач не аутентифікований, встановлюємо стани на null/false\n          setUser(null);\n          setIsAdmin(false);\n          // setUserId(null);\n          setHasDevice(false);\n          // Очищаємо будь-які застарілі дані аутентифікації з localStorage\n          localStorage.removeItem('userName');\n          localStorage.removeItem('isAdmin');\n          localStorage.removeItem('userId');\n          localStorage.removeItem('userProfilePictureUrl'); // Очищаємо URL фото\n        }\n      } catch (error) {\n        var _error$response;\n        console.error('Context: Initial auth check failed (API error):', error);\n        // У випадку помилки API (крім 401, який обробить перехоплювач), також встановлюємо стани на null/false\n        // Перехоплювач обробить 401 і викличе logoutUser, який очистить стани.\n        if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) !== 401) {\n          setUser(null);\n          setIsAdmin(false);\n          // setUserId(null);\n          setHasDevice(false);\n          // Очищаємо localStorage при помилці\n          localStorage.removeItem('userName');\n          localStorage.removeItem('isAdmin');\n          localStorage.removeItem('userId');\n          localStorage.removeItem('userProfilePictureUrl'); // Очищаємо URL фото\n        }\n      } finally {\n        // Початкове завантаження контексту завершено\n        setLoadingInitial(false);\n        console.log('Context: Initial auth check useEffect finished. setLoadingInitial(false).');\n        // Переконаємося, що loadingDevice також false, якщо він не був запущений/завершений checkDeviceStatus\n        // Ця перевірка може бути складною, але якщо user === null тут, то checkDeviceStatus не був запущений успішно.\n        if (user === null && loadingDevice) {\n          // Перевірка на всяк випадок\n          setLoadingDevice(false);\n        }\n      }\n    };\n\n    // Запускаємо початкову перевірку аутентифікації\n    // Ми НЕ ІНІЦІАЛІЗУЄМО СТАН `user` З localStorage ТУТ! Ми покладаємося на `/auth/me`.\n    checkAuthStatus();\n  }, [checkDeviceStatus]); // Залежність від checkDeviceStatus (який є useCallback)\n\n  // --- Логіка Виходу ---\n  // Ця функція очищає локальний стан та localStorage.\n  // Виклик API `/auth/logout` має відбуватися перед цим, у компоненті, що ініціює вихід.\n  const logoutUser = useCallback(() => {\n    console.log('Context: logoutUser called (local cleanup).');\n\n    // !!! Очищення локального стану контексту !!!\n    setUser(null); // Встановлюємо користувача в null\n    setIsAdmin(false);\n    // setUserId(null);\n    setHasDevice(false); // При виході пристрою точно немає\n    setLoadingDevice(false); // При виході скасовуємо будь-яке завантаження пристрою\n    setError(null); // Очищаємо помилки\n\n    // !!! Очищення відповідних даних з localStorage !!!\n    localStorage.removeItem('userName');\n    localStorage.removeItem('isAdmin');\n    localStorage.removeItem('userId');\n    localStorage.removeItem('userProfilePictureUrl'); // !!! Очищаємо URL фотографії профілю !!!\n    // localStorage.removeItem('token'); // Якщо зберігаєте токен у localStorage\n\n    // Перенаправлення на /login сторінку відбувається в App (або роутері),\n    // який спостерігає за зміною стану 'user' на null.\n  }, []); // Немає залежностей, оскільки залежить лише від сеттерів станів та localStorage\n\n  // --- Зв'язуємо logoutUser з перехоплювачем API ---\n  // Цей ефект гарантує, що logoutUser викликається, якщо API повертає 401 Unauthorized\n  useEffect(() => {\n    console.log('Context: Setting API unauthorized callback.');\n    setUnauthorizedCallback(logoutUser);\n\n    // Функція очищення, яка спрацює при демонтажі компонента UserProvider\n    return () => {\n      console.log('Context: Clearing API unauthorized callback.');\n      setUnauthorizedCallback(null);\n    };\n  }, [logoutUser]); // Залежність від logoutUser (який є useCallback)\n\n  // --- Функція для обробки успіху логіну (викликається з LoginPage) ---\n  const handleLoginSuccess = useCallback(userDataFromLogin => {\n    console.log('Context: handleLoginSuccess called.');\n    // !!! Встановлюємо ПОВНИЙ об'єкт користувача, отриманий з LoginPage !!!\n    // Цей об'єкт має містити усі поля, які повернув бекенд при логіні, включаючи profile_picture_url\n    setUser(userDataFromLogin);\n    // Оновлюємо похідні стани з отриманих даних логіну\n    setIsAdmin(userDataFromLogin.is_admin || false);\n    // setUserId(userDataFromLogin.id);\n\n    setError(null); // Очищаємо помилки\n\n    // ЗАПУСКАЄМО ПЕРЕВІРКУ ПРИСТРОЮ ПІСЛЯ УСПІШНОГО ЛОГІНУ\n    // Передаємо об'єкт користувача, отриманий з логіну, щоб checkDeviceStatus мав актуальні дані\n    checkDeviceStatus(userDataFromLogin);\n\n    // Збереження в localStorage (userName, isAdmin, userId, profile_picture_url)\n    // тепер відбувається у компоненті LoginPage ПЕРЕД викликом handleLoginSuccess.\n  }, [checkDeviceStatus]); // Залежність від checkDeviceStatus\n\n  // Значення контексту, що надається іншим компонентам\n  const contextValue = {\n    user,\n    // !!! Надаємо ПОВНИЙ об'єкт користувача (з profile_picture_url) або null !!!\n    isAdmin,\n    // boolean\n    userId: (user === null || user === void 0 ? void 0 : user.id) || null,\n    // Отримуємо userId з об'єкта user або null, якщо user === null\n    hasDevice,\n    // boolean (статус пристрою)\n    loadingInitial,\n    // boolean (чи йде початкове завантаження контексту)\n    loadingDevice,\n    // boolean (чи йде перевірка пристрою)\n    error,\n    // any (помилка контексту)\n    logoutUser,\n    // Функція для виходу (локальне очищення + очищення LS)\n    handleLoginSuccess,\n    // Функція для LoginPage при успішному логіні\n    checkDeviceStatus // Може знадобитись деінде для оновлення статусу пристрою вручну\n  };\n  return /*#__PURE__*/_jsxDEV(UserContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 235,\n    columnNumber: 9\n  }, this);\n};\n_s(UserProvider, \"61zj7t1JIIy5elMktSEvK6tesX4=\");\n_c = UserProvider;\nvar _c;\n$RefreshReg$(_c, \"UserProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useCallback","useRef","api","setUnauthorizedCallback","jsxDEV","_jsxDEV","UserContext","UserProvider","children","_s","user","setUser","isAdmin","setIsAdmin","hasDevice","setHasDevice","loadingDevice","setLoadingDevice","loadingInitial","setLoadingInitial","error","setError","isInitialAuthCheckDone","checkDeviceStatus","currentUser","console","log","devicesRes","get","userHasDevice","data","length","err","_err$response","response","status","current","checkAuthStatus","res","withCredentials","fetchedUser","is_admin","profile_picture_url","localStorage","setItem","removeItem","_error$response","logoutUser","handleLoginSuccess","userDataFromLogin","contextValue","userId","id","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/Program Files/WebstormProjects/soil_scout/web/src/contexts/UserContext.js"],"sourcesContent":["// src/contexts/UserContext.js\r\nimport React, { createContext, useState, useEffect, useCallback, useRef } from 'react';\r\n// Імпортуємо лише setUnauthorizedCallback\r\nimport api, { setUnauthorizedCallback } from '../utils/api'; // ВИДАЛЕНО: setIsLoggingOut\r\n\r\nexport const UserContext = createContext();\r\n\r\nexport const UserProvider = ({ children }) => {\r\n    // !!! Стан користувача буде зберігати ПОВНИЙ об'єкт користувача або null !!!\r\n    // Початковий стан - null. Дані будуть завантажені при початковій перевірці аутентифікації.\r\n    const [user, setUser] = useState(null);\r\n\r\n    // Ці стани можна отримати з об'єкта user, але зберігаємо їх окремо для зручності,\r\n    // якщо вони активно використовуються в різних компонентах.\r\n    const [isAdmin, setIsAdmin] = useState(false); // Буде встановлюватися з user.is_admin\r\n    // const [userId, setUserId] = useState(null); // userId можна отримати з user?.id\r\n\r\n    const [hasDevice, setHasDevice] = useState(false);\r\n    const [loadingDevice, setLoadingDevice] = useState(false);\r\n    const [loadingInitial, setLoadingInitial] = useState(true); // Старт з true\r\n    const [error, setError] = useState(null); // Загальний стан помилки\r\n\r\n    // Реф для відстеження, чи була виконана початкова перевірка аутентифікації\r\n    const isInitialAuthCheckDone = useRef(false); // Змінено назву для ясності\r\n\r\n\r\n    // --- Функція перевірки наявності пристрою ---\r\n    // Викликається після успішної аутентифікації або при початковій перевірці\r\n    const checkDeviceStatus = useCallback(async (currentUser) => {\r\n        // Робимо перевірку лише якщо користувач виглядає залогіненим (присутній user об'єкт)\r\n        // і ми ще не перевіряємо його пристрій\r\n        if (!currentUser) {\r\n            console.log('Context: checkDeviceStatus skipped - user is null.');\r\n            setHasDevice(false);\r\n            // setLoadingDevice(false); // Не скидаємо тут, скинемо у finally, якщо він був true\r\n            return; // Не виконуємо запит\r\n        }\r\n        // Перевіряємо loadingDevice тут, щоб уникнути повторних викликів\r\n        if (loadingDevice) {\r\n            console.log('Context: checkDeviceStatus skipped - already checking.');\r\n            return;\r\n        }\r\n\r\n\r\n        setLoadingDevice(true);\r\n        console.log('Context: Performing device status check...');\r\n        try {\r\n            const devicesRes = await api.get('/user-iot-devices'); // Ваш ендпоінт для перевірки пристроїв\r\n            const userHasDevice = devicesRes.data && devicesRes.data.length > 0;\r\n            setHasDevice(userHasDevice);\r\n            console.log(`Context: Device check successful. Has device: ${userHasDevice}.`);\r\n            // setError(null); // Можна очищати помилки, пов'язані з пристроєм\r\n\r\n        } catch (err) {\r\n            console.error('Context: Failed to fetch user devices:', err);\r\n            // Перехоплювач обробить 401 і викличе logoutUser.\r\n            // Для інших помилок, вважаємо, що пристрій недоступний у цей момент.\r\n            if (err.response?.status !== 401) {\r\n                setHasDevice(false); // Встановлюємо false при інших помилках запиту пристрою\r\n                // setError(err); // Можна встановити помилку, пов'язану з пристроєм\r\n            }\r\n        } finally {\r\n            setLoadingDevice(false); // Завершуємо завантаження статусу пристрою\r\n        }\r\n    }, [loadingDevice]); // Залежність від loadingDevice\r\n\r\n\r\n    // --- Початкова перевірка аутентифікації при монтуванні ---\r\n    // Цей ефект перевіряє, чи користувач вже аутентифікований (наприклад, за cookie),\r\n    // і завантажує його повні дані з бекенду.\r\n    useEffect(() => {\r\n        // Використовуємо реф, щоб переконатися, що цей ефект спрацює лише один раз при першому монтуванні\r\n        if (isInitialAuthCheckDone.current) {\r\n            console.log('Context: Initial auth check already done, skipping useEffect.');\r\n            return;\r\n        }\r\n\r\n        isInitialAuthCheckDone.current = true; // Позначаємо, що перевірка почалася\r\n        console.log('Context: Starting initial auth check useEffect.');\r\n\r\n        const checkAuthStatus = async () => {\r\n            try {\r\n                // Викликаємо бекенд-ендпоінт для отримання даних поточного аутентифікованого користувача\r\n                // Цей ендпоінт /auth/me має повертати ПОВНИЙ об'єкт користувача, включаючи profile_picture_url\r\n                const res = await api.get('/auth/me', { withCredentials: true });\r\n                // Припускаємо, що дані користувача знаходяться у res.data.user\r\n                const fetchedUser = res.data.user;\r\n\r\n                if (fetchedUser) {\r\n                    console.log('Context: Initial auth check successful. Fetched user data:', fetchedUser);\r\n                    // !!! Встановлюємо ПОВНИЙ об'єкт користувача у стан контексту !!!\r\n                    setUser(fetchedUser);\r\n                    // Оновлюємо похідні стани з отриманих даних\r\n                    setIsAdmin(fetchedUser.is_admin || false); // Переконаємося, що це boolean\r\n                    // userId можна отримати з fetchedUser.id, якщо він потрібен окремо\r\n\r\n                    // Зберігаємо URL фото в localStorage, якщо він прийшов\r\n                    if (fetchedUser.profile_picture_url) {\r\n                        localStorage.setItem('userProfilePictureUrl', fetchedUser.profile_picture_url);\r\n                        console.log('Context: Profile picture URL saved to localStorage from /auth/me.');\r\n                    } else {\r\n                        localStorage.removeItem('userProfilePictureUrl'); // Видаляємо, якщо не прийшов\r\n                        console.log('Context: No profile picture URL from /auth/me, removed from localStorage.');\r\n                    }\r\n\r\n\r\n                    // Запускаємо перевірку статусу пристрою для завантаженого користувача\r\n                    checkDeviceStatus(fetchedUser); // Передаємо повний об'єкт користувача\r\n\r\n                } else {\r\n                    console.log('Context: No active session found during initial /auth/me check.');\r\n                    // Якщо користувач не аутентифікований, встановлюємо стани на null/false\r\n                    setUser(null);\r\n                    setIsAdmin(false);\r\n                    // setUserId(null);\r\n                    setHasDevice(false);\r\n                    // Очищаємо будь-які застарілі дані аутентифікації з localStorage\r\n                    localStorage.removeItem('userName');\r\n                    localStorage.removeItem('isAdmin');\r\n                    localStorage.removeItem('userId');\r\n                    localStorage.removeItem('userProfilePictureUrl'); // Очищаємо URL фото\r\n                }\r\n            } catch (error) {\r\n                console.error('Context: Initial auth check failed (API error):', error);\r\n                // У випадку помилки API (крім 401, який обробить перехоплювач), також встановлюємо стани на null/false\r\n                // Перехоплювач обробить 401 і викличе logoutUser, який очистить стани.\r\n                if (error.response?.status !== 401) {\r\n                    setUser(null);\r\n                    setIsAdmin(false);\r\n                    // setUserId(null);\r\n                    setHasDevice(false);\r\n                    // Очищаємо localStorage при помилці\r\n                    localStorage.removeItem('userName');\r\n                    localStorage.removeItem('isAdmin');\r\n                    localStorage.removeItem('userId');\r\n                    localStorage.removeItem('userProfilePictureUrl'); // Очищаємо URL фото\r\n                }\r\n            } finally {\r\n                // Початкове завантаження контексту завершено\r\n                setLoadingInitial(false);\r\n                console.log('Context: Initial auth check useEffect finished. setLoadingInitial(false).');\r\n                // Переконаємося, що loadingDevice також false, якщо він не був запущений/завершений checkDeviceStatus\r\n                // Ця перевірка може бути складною, але якщо user === null тут, то checkDeviceStatus не був запущений успішно.\r\n                if (user === null && loadingDevice) { // Перевірка на всяк випадок\r\n                    setLoadingDevice(false);\r\n                }\r\n            }\r\n        };\r\n\r\n        // Запускаємо початкову перевірку аутентифікації\r\n        // Ми НЕ ІНІЦІАЛІЗУЄМО СТАН `user` З localStorage ТУТ! Ми покладаємося на `/auth/me`.\r\n        checkAuthStatus();\r\n\r\n    }, [checkDeviceStatus]); // Залежність від checkDeviceStatus (який є useCallback)\r\n\r\n\r\n    // --- Логіка Виходу ---\r\n    // Ця функція очищає локальний стан та localStorage.\r\n    // Виклик API `/auth/logout` має відбуватися перед цим, у компоненті, що ініціює вихід.\r\n    const logoutUser = useCallback(() => {\r\n        console.log('Context: logoutUser called (local cleanup).');\r\n\r\n        // !!! Очищення локального стану контексту !!!\r\n        setUser(null); // Встановлюємо користувача в null\r\n        setIsAdmin(false);\r\n        // setUserId(null);\r\n        setHasDevice(false); // При виході пристрою точно немає\r\n        setLoadingDevice(false); // При виході скасовуємо будь-яке завантаження пристрою\r\n        setError(null); // Очищаємо помилки\r\n\r\n        // !!! Очищення відповідних даних з localStorage !!!\r\n        localStorage.removeItem('userName');\r\n        localStorage.removeItem('isAdmin');\r\n        localStorage.removeItem('userId');\r\n        localStorage.removeItem('userProfilePictureUrl'); // !!! Очищаємо URL фотографії профілю !!!\r\n        // localStorage.removeItem('token'); // Якщо зберігаєте токен у localStorage\r\n\r\n        // Перенаправлення на /login сторінку відбувається в App (або роутері),\r\n        // який спостерігає за зміною стану 'user' на null.\r\n\r\n    }, []); // Немає залежностей, оскільки залежить лише від сеттерів станів та localStorage\r\n\r\n\r\n    // --- Зв'язуємо logoutUser з перехоплювачем API ---\r\n    // Цей ефект гарантує, що logoutUser викликається, якщо API повертає 401 Unauthorized\r\n    useEffect(() => {\r\n        console.log('Context: Setting API unauthorized callback.');\r\n        setUnauthorizedCallback(logoutUser);\r\n\r\n        // Функція очищення, яка спрацює при демонтажі компонента UserProvider\r\n        return () => {\r\n            console.log('Context: Clearing API unauthorized callback.');\r\n            setUnauthorizedCallback(null);\r\n        };\r\n    }, [logoutUser]); // Залежність від logoutUser (який є useCallback)\r\n\r\n\r\n    // --- Функція для обробки успіху логіну (викликається з LoginPage) ---\r\n    const handleLoginSuccess = useCallback((userDataFromLogin) => {\r\n        console.log('Context: handleLoginSuccess called.');\r\n        // !!! Встановлюємо ПОВНИЙ об'єкт користувача, отриманий з LoginPage !!!\r\n        // Цей об'єкт має містити усі поля, які повернув бекенд при логіні, включаючи profile_picture_url\r\n        setUser(userDataFromLogin);\r\n        // Оновлюємо похідні стани з отриманих даних логіну\r\n        setIsAdmin(userDataFromLogin.is_admin || false);\r\n        // setUserId(userDataFromLogin.id);\r\n\r\n        setError(null); // Очищаємо помилки\r\n\r\n        // ЗАПУСКАЄМО ПЕРЕВІРКУ ПРИСТРОЮ ПІСЛЯ УСПІШНОГО ЛОГІНУ\r\n        // Передаємо об'єкт користувача, отриманий з логіну, щоб checkDeviceStatus мав актуальні дані\r\n        checkDeviceStatus(userDataFromLogin);\r\n\r\n        // Збереження в localStorage (userName, isAdmin, userId, profile_picture_url)\r\n        // тепер відбувається у компоненті LoginPage ПЕРЕД викликом handleLoginSuccess.\r\n\r\n    }, [checkDeviceStatus]); // Залежність від checkDeviceStatus\r\n\r\n\r\n    // Значення контексту, що надається іншим компонентам\r\n    const contextValue = {\r\n        user, // !!! Надаємо ПОВНИЙ об'єкт користувача (з profile_picture_url) або null !!!\r\n        isAdmin, // boolean\r\n        userId: user?.id || null, // Отримуємо userId з об'єкта user або null, якщо user === null\r\n        hasDevice, // boolean (статус пристрою)\r\n        loadingInitial, // boolean (чи йде початкове завантаження контексту)\r\n        loadingDevice, // boolean (чи йде перевірка пристрою)\r\n        error, // any (помилка контексту)\r\n        logoutUser, // Функція для виходу (локальне очищення + очищення LS)\r\n        handleLoginSuccess, // Функція для LoginPage при успішному логіні\r\n        checkDeviceStatus, // Може знадобитись деінде для оновлення статусу пристрою вручну\r\n    };\r\n\r\n    return (\r\n        <UserContext.Provider value={contextValue}>\r\n            {children}\r\n        </UserContext.Provider>\r\n    );\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}